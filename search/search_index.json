{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This site contains all the course plans, labs, and materials for the Professional Bachelor's Degree in Cloud Computing at the UNIVERSITY OF THE MOUNTAINS (UdM). Available Courses UCC111 - Linux Foundational Covers the fundamentals of Linux installation, disk management, and package management. Go to course UCC121 - Linux Expert A two-part course covering advanced shell scripting and the use of AI in system administration. Go to course UCC141 - Virtualization Fundamentals Covers virtualization fundamentals. Go to course About This Site This site is built with MkDocs and Material for MkDocs. It is automatically deployed via GitHub Actions.","title":"Home"},{"location":"#available-courses","text":"UCC111 - Linux Foundational Covers the fundamentals of Linux installation, disk management, and package management. Go to course UCC121 - Linux Expert A two-part course covering advanced shell scripting and the use of AI in system administration. Go to course UCC141 - Virtualization Fundamentals Covers virtualization fundamentals. Go to course","title":"Available Courses"},{"location":"#about-this-site","text":"This site is built with MkDocs and Material for MkDocs. It is automatically deployed via GitHub Actions.","title":"About This Site"},{"location":"ucc111/","text":"This module covers linux installation and package management. Sections UCC111-2: Linux Installation and Package Management","title":"UCC111"},{"location":"ucc111/#sections","text":"UCC111-2: Linux Installation and Package Management","title":"Sections"},{"location":"ucc111/installation_and_pkg_mgnt/","text":"This course is part of the Teaching Unit (TU): UCC111 - Linux Foundational (LPIC-101). Preamble Purpose : To provide the essential basics for installing, managing startup, and maintaining software on Linux systems, which are fundamental skills for working on servers and in cloud environments. Target audience : Students in the Professional Bachelor's Degree in Cloud Computing (Semester 1). Type of access : Paid (UoM Standard). Hours : 12 Teaching mode : CS (Synchronous Chat), CA (Asynchronous Chat) (UdM Standard). prerequisites : None Summary This course covers the key concepts necessary for setting up a functional Linux system. It addresses storage preparation (disk design), boot system installation, and, above all, effective management of software packages and libraries for the main Linux distribution families (Debian/RPM). Glossary Linux distribution : A coherent set consisting of the Linux kernel, a package manager, and a set of tools and applications (e.g., Ubuntu, Debian, Fedora). Kernel : The core of the operating system that manages hardware resources, processes, memory, and peripherals. CLI (Command Line Interface) : Command line interface, used to administer the system without a graphical interface. ISO : Installation image of an operating system containing the files necessary for installation. Bootloader : Program loaded when the PC starts up, allowing the operating system to be launched. GRUB (GRand Unified Bootloader) : Bootloader widely used on Linux systems, configurable and multi-OS. UEFI (Unified Extensible Firmware Interface) : Modern replacement for BIOS, enabling advanced boot management and GPT disk support. BIOS (Basic Input/Output System) : Legacy firmware that manages hardware initialization at startup. Dual-Boot : Configuration allowing multiple operating systems to coexist on the same machine. MBR (Master Boot Record) : Old partitioning scheme limited to 2 TB and 4 primary partitions. GPT (GUID Partition Table) : Modern partitioning scheme supporting large disks and an unlimited number of partitions. Partition : Logical division of a disk used to store systems or data. Swap : Disk space used as an extension of RAM. Mount point : Directory in which a partition or external disk is integrated into the Linux tree structure. fstab : File containing the configuration of file systems to be mounted automatically. Shared library (.so) : File containing code that can be reused by several programs simultaneously, avoiding duplication. ldconfig : Command that updates the shared library cache. ld.so.conf : File listing the paths containing dynamic libraries. Dependency : A package or file required for another program to function properly. Package : File containing a program, its data, and metadata, managed via a manager. dpkg : Low-level package manager on Debian/Ubuntu that allows you to install or remove .deb files. apt (Advanced Package Tool) : High-level manager that automatically resolves dependencies and manages repositories. Repository : Server containing software packages accessible via APT. sources.list : File containing the list of repositories used by APT. RPM (Red Hat Package Manager) : Package format and low-level manager used on RHEL, CentOS, Fedora. YUM (Yellowdog Updater Modified) : Former high-level manager for RPM systems allowing automatic installation of dependencies. DNF (Dandified Yum) : A modern replacement for YUM, faster and more reliable. Package group : A set of related software programs that can be installed together (e.g., web server, graphical environment). Log : File containing system events and actions, useful for diagnosing errors. Broken package : A package that is partially installed or contains unmet dependencies. Package manager lock : Situation where another process (e.g., automatic update) prevents the installation of new packages. APT/YUM cache : Folder containing metadata and previously downloaded packages. Checksum (SHA256) : Fingerprint used to verify the integrity of a downloaded ISO image. GPG (GNU Privacy Guard) : Encryption tool used to verify the authenticity of repositories and packages. lsblk / fdisk / parted : Commands for inspecting and managing disks and partitions. mount / umount : Commands used to mount or unmount a file system. systemctl : Command for managing services, useful for checking whether an installed service is working correctly. Learning objectives By the end of this course, students should be able to: Master the installation of a Linux system Prepare installation media (ISO, bootable USB drive). Choose and configure an appropriate partitioning scheme (MBR/GPT). Understand and apply the file system hierarchy Configure and manage system startup Understand the role of the bootloader (GRUB). Install, repair, and customize GRUB. Manage multi-boot environments. Manage system libraries and dependencies. Identify shared libraries (.so). Manipulate the library cache via ldconfig. Resolve issues related to missing dependencies. Install, update, and remove packages. Use low-level tools (dpkg, rpm). Master high-level managers (apt, yum/dnf). Configure software repositories and manage GPG keys. Diagnose and maintain a functional Linux system. Detect and repair broken packages. Read the logs related to package installation. Assessment Teaching strategies adopted: The specific assessment method is: Continuous assessment, Practical work, Final exam. Standard school protocol: Continuous assessment (CC) accounts for 30% of the overall mark, broken down as follows: (Participation in tutorials 20%, Completion of activities 20%, Attendance/presence in class 20%, Completion of practical work 40%) The written exam accounts for 70%. CHAPTER 1 - Introduction to Linux installation 1.1. Understanding Linux distributions Definition of a distribution Differences between distributions (Debian, Ubuntu, RHEL, CentOS, Fedora, etc.) Package management models according to families 1.2. Life cycle of a Linux system Installation Configuration Maintenance Updates and upgrades 1.3. Preparing for installation Choosing a distribution based on context ISO download and integrity check (SHA256, GPG) Creating bootable media (Rufus, Balena, dd) CHAPTER 2 \u2014 Disk design and organization 2.1. Partitioning types MBR vs. GPT Comparison and limitations Primary, extended, and logical partition tables 2.2. Partition types System partition Swap partition /home partition /boot partition EFI partition (ESP) 2.3. Linux file systems Ext2, Ext3, Ext4 XFS, Btrfs FAT32, NTFS (compatibility) 2.4. Mount points Role of the mount point File system hierarchy (FHS) Automatic mounting: /etc/fstab Mount options (rw, ro, noexec, etc.) CHAPTER 3 - Installation and management of bootloaders 3.1. How a bootloader works Definition and role BIOS/UEFI interaction Linux boot chain 3.2. GRUB2 - Installation and configuration GRUB structure: grub.cfg, scripts Menu customization Modifying boot options Recovery modes 3.3. Bootloader troubleshooting Reinstalling GRUB Handling common errors (error 15, no such device, etc.) Backup and restore 3.4. Special case: Multi-boot Dual-boot with Windows Automatic detection via os-prober Boot order CHAPTER 4 \u2014 Shared Library Management 4.1. Understanding shared libraries .so files Dynamic links Application dependencies 4.2. Library identification and configuration The ldd command Configuration file /etc/ld.so.conf Standard library directories 4.3. Library cache management ldconfig function Creating symbolic links Cache update CHAPTER 5 \u2014 Package management in Debian and derivative distributions 5.1. Basic package management with dpkg Local installation of a .deb Removal and purging Inspection with dpkg -l, -s, -c 5.2. Advanced package management Manipulation of configuration files Status and partial installation of packages Troubleshooting incomplete installations 5.3. Managing repositories with APT /etc/apt/sources.list Adding repositories and GPG keys Updating lists: apt update 5.4. Common operations with APT Installation, upgrade, removal Search and diagnostics Major upgrade (dist-upgrade, full-upgrade) 5.5. Meta package management Tasksel Functional groups CHAPTER 6 - Package management in RedHat, Fedora, and derivatives 6.1. Basic management with RPM Installing an .rpm Signature verification Querying RPM packages 6.2. Using YUM/DNF Manager architecture: repositories, cache, metadata Essential commands: installation, removal, update 6.3. Advanced management Package groups Cache cleanup Conflict and broken dependency management 6.4. Repository configuration Creating a local repository Adding an external repository Temporary activation/deactivation CHAPTER 7 - System maintenance and diagnostics 7.1. Updating the system Security Critical patches Automatic Updates (cron, systemd timers) 7.2. Diagnosing package-related problems Missing dependencies Broken packages Packet manager locking 7.3. Logging and logs dpkg.log yum.log / dnf.log journalctl for issues related to installed services CHAPTER 8 - Practical exercises 8.1. Lab 1: Complete installation of Linux on a VM 8.2. Lab 2: Manual MBR and GPT partitioning 8.3. TP 3: Installation and configuration of GRUB 8.4. TP 4: Installing packages on Debian and RedHat 8.5. TP 5: Creating a local repository (Debian or RPM) Activities Learning activity (tutorials), Assessment activity (tutorials + corrected assignments), Self-assessment activity (self-assessment test or multiple-choice questions), Summative activity (problem situation). Bibliographies and list of links Provide a list of resources for further study of the course content. (UdM standard)","title":"Linux Installation and Package Management"},{"location":"ucc111/installation_and_pkg_mgnt/#preamble","text":"Purpose : To provide the essential basics for installing, managing startup, and maintaining software on Linux systems, which are fundamental skills for working on servers and in cloud environments. Target audience : Students in the Professional Bachelor's Degree in Cloud Computing (Semester 1). Type of access : Paid (UoM Standard). Hours : 12 Teaching mode : CS (Synchronous Chat), CA (Asynchronous Chat) (UdM Standard). prerequisites : None","title":"Preamble"},{"location":"ucc111/installation_and_pkg_mgnt/#summary","text":"This course covers the key concepts necessary for setting up a functional Linux system. It addresses storage preparation (disk design), boot system installation, and, above all, effective management of software packages and libraries for the main Linux distribution families (Debian/RPM).","title":"Summary"},{"location":"ucc111/installation_and_pkg_mgnt/#glossary","text":"Linux distribution : A coherent set consisting of the Linux kernel, a package manager, and a set of tools and applications (e.g., Ubuntu, Debian, Fedora). Kernel : The core of the operating system that manages hardware resources, processes, memory, and peripherals. CLI (Command Line Interface) : Command line interface, used to administer the system without a graphical interface. ISO : Installation image of an operating system containing the files necessary for installation. Bootloader : Program loaded when the PC starts up, allowing the operating system to be launched. GRUB (GRand Unified Bootloader) : Bootloader widely used on Linux systems, configurable and multi-OS. UEFI (Unified Extensible Firmware Interface) : Modern replacement for BIOS, enabling advanced boot management and GPT disk support. BIOS (Basic Input/Output System) : Legacy firmware that manages hardware initialization at startup. Dual-Boot : Configuration allowing multiple operating systems to coexist on the same machine. MBR (Master Boot Record) : Old partitioning scheme limited to 2 TB and 4 primary partitions. GPT (GUID Partition Table) : Modern partitioning scheme supporting large disks and an unlimited number of partitions. Partition : Logical division of a disk used to store systems or data. Swap : Disk space used as an extension of RAM. Mount point : Directory in which a partition or external disk is integrated into the Linux tree structure. fstab : File containing the configuration of file systems to be mounted automatically. Shared library (.so) : File containing code that can be reused by several programs simultaneously, avoiding duplication. ldconfig : Command that updates the shared library cache. ld.so.conf : File listing the paths containing dynamic libraries. Dependency : A package or file required for another program to function properly. Package : File containing a program, its data, and metadata, managed via a manager. dpkg : Low-level package manager on Debian/Ubuntu that allows you to install or remove .deb files. apt (Advanced Package Tool) : High-level manager that automatically resolves dependencies and manages repositories. Repository : Server containing software packages accessible via APT. sources.list : File containing the list of repositories used by APT. RPM (Red Hat Package Manager) : Package format and low-level manager used on RHEL, CentOS, Fedora. YUM (Yellowdog Updater Modified) : Former high-level manager for RPM systems allowing automatic installation of dependencies. DNF (Dandified Yum) : A modern replacement for YUM, faster and more reliable. Package group : A set of related software programs that can be installed together (e.g., web server, graphical environment). Log : File containing system events and actions, useful for diagnosing errors. Broken package : A package that is partially installed or contains unmet dependencies. Package manager lock : Situation where another process (e.g., automatic update) prevents the installation of new packages. APT/YUM cache : Folder containing metadata and previously downloaded packages. Checksum (SHA256) : Fingerprint used to verify the integrity of a downloaded ISO image. GPG (GNU Privacy Guard) : Encryption tool used to verify the authenticity of repositories and packages. lsblk / fdisk / parted : Commands for inspecting and managing disks and partitions. mount / umount : Commands used to mount or unmount a file system. systemctl : Command for managing services, useful for checking whether an installed service is working correctly.","title":"Glossary"},{"location":"ucc111/installation_and_pkg_mgnt/#learning-objectives","text":"By the end of this course, students should be able to: Master the installation of a Linux system Prepare installation media (ISO, bootable USB drive). Choose and configure an appropriate partitioning scheme (MBR/GPT). Understand and apply the file system hierarchy Configure and manage system startup Understand the role of the bootloader (GRUB). Install, repair, and customize GRUB. Manage multi-boot environments. Manage system libraries and dependencies. Identify shared libraries (.so). Manipulate the library cache via ldconfig. Resolve issues related to missing dependencies. Install, update, and remove packages. Use low-level tools (dpkg, rpm). Master high-level managers (apt, yum/dnf). Configure software repositories and manage GPG keys. Diagnose and maintain a functional Linux system. Detect and repair broken packages. Read the logs related to package installation.","title":"Learning objectives"},{"location":"ucc111/installation_and_pkg_mgnt/#assessment","text":"Teaching strategies adopted: The specific assessment method is: Continuous assessment, Practical work, Final exam. Standard school protocol: Continuous assessment (CC) accounts for 30% of the overall mark, broken down as follows: (Participation in tutorials 20%, Completion of activities 20%, Attendance/presence in class 20%, Completion of practical work 40%) The written exam accounts for 70%.","title":"Assessment"},{"location":"ucc111/installation_and_pkg_mgnt/#chapter-1-introduction-to-linux-installation","text":"","title":"CHAPTER 1 - Introduction to Linux installation"},{"location":"ucc111/installation_and_pkg_mgnt/#11-understanding-linux-distributions","text":"Definition of a distribution Differences between distributions (Debian, Ubuntu, RHEL, CentOS, Fedora, etc.) Package management models according to families","title":"1.1. Understanding Linux distributions"},{"location":"ucc111/installation_and_pkg_mgnt/#12-life-cycle-of-a-linux-system","text":"Installation Configuration Maintenance Updates and upgrades","title":"1.2. Life cycle of a Linux system"},{"location":"ucc111/installation_and_pkg_mgnt/#13-preparing-for-installation","text":"Choosing a distribution based on context ISO download and integrity check (SHA256, GPG) Creating bootable media (Rufus, Balena, dd)","title":"1.3. Preparing for installation"},{"location":"ucc111/installation_and_pkg_mgnt/#chapter-2-disk-design-and-organization","text":"","title":"CHAPTER 2 \u2014 Disk design and organization"},{"location":"ucc111/installation_and_pkg_mgnt/#21-partitioning-types","text":"MBR vs. GPT Comparison and limitations Primary, extended, and logical partition tables","title":"2.1. Partitioning types"},{"location":"ucc111/installation_and_pkg_mgnt/#22-partition-types","text":"System partition Swap partition /home partition /boot partition EFI partition (ESP)","title":"2.2. Partition types"},{"location":"ucc111/installation_and_pkg_mgnt/#23-linux-file-systems","text":"Ext2, Ext3, Ext4 XFS, Btrfs FAT32, NTFS (compatibility)","title":"2.3. Linux file systems"},{"location":"ucc111/installation_and_pkg_mgnt/#24-mount-points","text":"Role of the mount point File system hierarchy (FHS) Automatic mounting: /etc/fstab Mount options (rw, ro, noexec, etc.)","title":"2.4. Mount points"},{"location":"ucc111/installation_and_pkg_mgnt/#chapter-3-installation-and-management-of-bootloaders","text":"","title":"CHAPTER 3 - Installation and management of bootloaders"},{"location":"ucc111/installation_and_pkg_mgnt/#31-how-a-bootloader-works","text":"Definition and role BIOS/UEFI interaction Linux boot chain","title":"3.1. How a bootloader works"},{"location":"ucc111/installation_and_pkg_mgnt/#32-grub2-installation-and-configuration","text":"GRUB structure: grub.cfg, scripts Menu customization Modifying boot options Recovery modes","title":"3.2. GRUB2 - Installation and configuration"},{"location":"ucc111/installation_and_pkg_mgnt/#33-bootloader-troubleshooting","text":"Reinstalling GRUB Handling common errors (error 15, no such device, etc.) Backup and restore","title":"3.3. Bootloader troubleshooting"},{"location":"ucc111/installation_and_pkg_mgnt/#34-special-case-multi-boot","text":"Dual-boot with Windows Automatic detection via os-prober Boot order","title":"3.4. Special case: Multi-boot"},{"location":"ucc111/installation_and_pkg_mgnt/#chapter-4-shared-library-management","text":"","title":"CHAPTER 4 \u2014 Shared Library Management"},{"location":"ucc111/installation_and_pkg_mgnt/#41-understanding-shared-libraries","text":".so files Dynamic links Application dependencies","title":"4.1. Understanding shared libraries"},{"location":"ucc111/installation_and_pkg_mgnt/#42-library-identification-and-configuration","text":"The ldd command Configuration file /etc/ld.so.conf Standard library directories","title":"4.2. Library identification and configuration"},{"location":"ucc111/installation_and_pkg_mgnt/#43-library-cache-management","text":"ldconfig function Creating symbolic links Cache update","title":"4.3. Library cache management"},{"location":"ucc111/installation_and_pkg_mgnt/#chapter-5-package-management-in-debian-and-derivative-distributions","text":"","title":"CHAPTER 5 \u2014 Package management in Debian and derivative distributions"},{"location":"ucc111/installation_and_pkg_mgnt/#51-basic-package-management-with-dpkg","text":"Local installation of a .deb Removal and purging Inspection with dpkg -l, -s, -c","title":"5.1. Basic package management with dpkg"},{"location":"ucc111/installation_and_pkg_mgnt/#52-advanced-package-management","text":"Manipulation of configuration files Status and partial installation of packages Troubleshooting incomplete installations","title":"5.2. Advanced package management"},{"location":"ucc111/installation_and_pkg_mgnt/#53-managing-repositories-with-apt","text":"/etc/apt/sources.list Adding repositories and GPG keys Updating lists: apt update","title":"5.3. Managing repositories with APT"},{"location":"ucc111/installation_and_pkg_mgnt/#54-common-operations-with-apt","text":"Installation, upgrade, removal Search and diagnostics Major upgrade (dist-upgrade, full-upgrade)","title":"5.4. Common operations with APT"},{"location":"ucc111/installation_and_pkg_mgnt/#55-meta-package-management","text":"Tasksel Functional groups","title":"5.5. Meta package management"},{"location":"ucc111/installation_and_pkg_mgnt/#chapter-6-package-management-in-redhat-fedora-and-derivatives","text":"","title":"CHAPTER 6 - Package management in RedHat, Fedora, and derivatives"},{"location":"ucc111/installation_and_pkg_mgnt/#61-basic-management-with-rpm","text":"Installing an .rpm Signature verification Querying RPM packages","title":"6.1. Basic management with RPM"},{"location":"ucc111/installation_and_pkg_mgnt/#62-using-yumdnf","text":"Manager architecture: repositories, cache, metadata Essential commands: installation, removal, update","title":"6.2. Using YUM/DNF"},{"location":"ucc111/installation_and_pkg_mgnt/#63-advanced-management","text":"Package groups Cache cleanup Conflict and broken dependency management","title":"6.3. Advanced management"},{"location":"ucc111/installation_and_pkg_mgnt/#64-repository-configuration","text":"Creating a local repository Adding an external repository Temporary activation/deactivation","title":"6.4. Repository configuration"},{"location":"ucc111/installation_and_pkg_mgnt/#chapter-7-system-maintenance-and-diagnostics","text":"","title":"CHAPTER 7 - System maintenance and diagnostics"},{"location":"ucc111/installation_and_pkg_mgnt/#71-updating-the-system","text":"Security Critical patches Automatic Updates (cron, systemd timers)","title":"7.1. Updating the system"},{"location":"ucc111/installation_and_pkg_mgnt/#72-diagnosing-package-related-problems","text":"Missing dependencies Broken packages Packet manager locking","title":"7.2. Diagnosing package-related problems"},{"location":"ucc111/installation_and_pkg_mgnt/#73-logging-and-logs","text":"dpkg.log yum.log / dnf.log journalctl for issues related to installed services","title":"7.3. Logging and logs"},{"location":"ucc111/installation_and_pkg_mgnt/#chapter-8-practical-exercises","text":"8.1. Lab 1: Complete installation of Linux on a VM 8.2. Lab 2: Manual MBR and GPT partitioning 8.3. TP 3: Installation and configuration of GRUB 8.4. TP 4: Installing packages on Debian and RedHat 8.5. TP 5: Creating a local repository (Debian or RPM)","title":"CHAPTER 8 - Practical exercises"},{"location":"ucc111/installation_and_pkg_mgnt/#activities","text":"Learning activity (tutorials), Assessment activity (tutorials + corrected assignments), Self-assessment activity (self-assessment test or multiple-choice questions), Summative activity (problem situation).","title":"Activities"},{"location":"ucc111/installation_and_pkg_mgnt/#bibliographies-and-list-of-links","text":"Provide a list of resources for further study of the course content. (UdM standard)","title":"Bibliographies and list of links"},{"location":"ucc111/labs/lab1/","text":"Scenario: Welcome back, specialists. A critical, minimalist web server has suffered a catastrophic failure. The only thing that remains is the client's requirement: a fast, secure, and minimal Debian system. Your task is to rebuild it from the ground up. This isn't just about getting a system running; it's about building it with intention, precision, and an understanding of the components, just like you would in a real-world data center. We will use the Debian netinst (network install) image, which is small and requires you to pull packages from the network, forcing a deliberate choice of what goes into our system. Prerequisites: A hypervisor (VirtualBox, KVM/QEMU, VMware) installed. Debian 12 Network Install ISO downloaded. Core Concepts Refresher: Your LPIC-101/102 knowledge is sound, but a year is a long time. Refresh your memory on: Logical Volume Management (LVM): Why it's superior to standard partitions for server environments (flexibility, snapshots). debootstrap: A tool to install a basic Debian system into a subdirectory of another, already-installed system. chroot: (change root) A way to run commands and an interactive shell within a different root directory. Essential for system recovery and custom builds. Level 1: The Foundation (Standard Complexity) Goal: Build a minimal, functional Debian server using the expert guided installer and LVM for a flexible disk layout. Instructions: VM Creation: Create a new VM. Name it phoenix-server . Assign it: 2 vCPUs, 2048 MB RAM, and a new 20 GB virtual disk. Mount the Debian netinst ISO and boot the VM. Expert Installation: From the boot menu, select Advanced options > Expert install . This mode exposes every step of the installation process. Proceed through the initial steps (language, location, keyboard). Partitioning with LVM (The Core Task): When you reach the partitioning step, choose Manual . Create a new partition table on your virtual disk. Create a small 512MB primary partition at the beginning of the disk. Set its \"Use as\" type to Ext4 and its mount point to /boot . Create a second, larger primary partition using the remaining space. Set its \"Use as\" type to physical volume for LVM . Now, navigate to the \"Configure the Logical Volume Manager\" menu. Create a Volume Group (VG) named vg_phoenix . Inside vg_phoenix , create three Logical Volumes (LVs): lv_root : 10 GB, to be used for the root filesystem ( / ). lv_home : 5 GB, to be used for user data ( /home ). lv_swap : 2 GB, to be used for swap space. Finish the LVM configuration and assign each LV its filesystem type (Ext4 for root/home, swap for swap) and mount point. Minimal Package Installation: Proceed with the base system installation. When you reach \"Software selection,\" deselect everything , especially the \"Debian desktop environment.\" The only two options that should be checked are: SSH server standard system utilities This ensures our server is lean and has no unnecessary graphical components. Finalize and Verify: Install the GRUB bootloader to the primary drive (e.g., /dev/vda ). Finish the installation and reboot. The system will boot to a command-line interface. From your host machine's terminal, SSH into the new server ( ssh user@<vm_ip_address> ). Verification Commands: Run the following to confirm your setup. What does each one tell you? lsblk (Should show your LVM layout) df -h (Should show your filesystems mounted) free -m (Should show your swap space is active) dpkg --get-selections | wc -l (How many packages are installed? A minimal system is a happy system.) Level 2: The Optimization (Advanced Complexity) Goal: Harden the base installation, automate package deployment, and prepare it for a \"production\" role. Instructions: SSH Hardening: Modify /etc/ssh/sshd_config on phoenix-server to enhance security. Disable root login ( PermitRootLogin no ). Disable password-based authentication ( PasswordAuthentication no ). On your host machine, generate an SSH key ( ssh-keygen ) if you don't have one, and copy the public key to the server ( ssh-copy-id user@<vm_ip_address> ). Restart the SSH service ( systemctl restart sshd ) and verify you can still log in (it should now be passwordless). Firewall Configuration: Install the Uncomplicated Firewall: apt install ufw . Configure it to deny all incoming traffic by default. Explicitly allow SSH traffic. What port does SSH use? Enable the firewall. Verify its status. Create a Personal Package Repository: On the server, install nginx : apt install nginx . Create a simple dummy Debian package. You don't need to write code; the goal is to create the package structure. # Install packaging tools sudo apt install build-essential devscripts debhelper dh-make # Create a project mkdir ~/dummy-pkg-1.0 && cd ~/dummy-pkg-1.0 dh_make --native -s -y # Build the package (ignore warnings) debuild -us -uc - You will find a `.deb` file in the parent directory . - Create a directory in the `nginx` web root ( `/var/www/html/debian` ) and copy your `.deb` file there . - Configure `nginx` to serve this directory . - On the server itself , add your own `nginx` server as an APT repository in `/etc/apt/sources.list` . - Run `apt update` and then install your `dummy-pkg` . Level 3: The Recovery & Deep Dive (Expert Complexity) Goal: Simulate a catastrophic failure and rebuild the system without the installer, using only command-line tools. This is the ultimate test of system understanding. Instructions: Simulated Disaster: GRUB is Gone! On your working phoenix-server from Level 1, simulate a bootloader overwrite: sudo dd if=/dev/zero of=/dev/sda bs=446 count=1 Reboot the VM. It will fail to boot, likely with a \"No bootable medium\" error. The server is dead. Or is it? Manual System Rescue: Boot the VM using the Debian netinst ISO again. From the main menu, select Advanced options > Rescue mode . The rescue environment will try to find your existing installation. Let it guide you to mount your LVM root partition under /target . If it fails, you must do it manually using the provided shell. The key step: chroot /target . You are now inside your broken system, with the tools from the live CD. Your task: From within the chroot, fix the system. What commands do you need to run? You'll need to mount /boot . You'll need to reinstall GRUB. (Hint: grub-install /dev/sda1 ) You might need to update GRUB's configuration. Exit the chroot , reboot without the ISO, and watch your server rise from the ashes. The debootstrap Challenge: If you complete the rescue, the final challenge awaits. Destroy your VM and create a new one. This time, do not use the installer at all. Boot into Rescue Mode from the start. From the command line, perform a full manual installation: Partition the disk ( parted or fdisk ). Create the LVM structure ( pvcreate , vgcreate , lvcreate ). Format the filesystems ( mkfs.ext4 , mkswap ). Mount everything under /mnt (e.g., root on /mnt , boot on /mnt/boot ). Use debootstrap to install the Debian 'bookworm' release into /mnt . chroot into /mnt and manually install a kernel ( apt install linux-image-amd64 ), GRUB ( apt install grub-pc ), configure /etc/fstab , set a root password ( passwd ), and create a user. If you can successfully boot this manually-built system, you have demonstrated a true mastery of the Linux installation process.","title":"Lab 1 - The Phoenix Server"},{"location":"ucc111/labs/lab1/#level-1-the-foundation-standard-complexity","text":"Goal: Build a minimal, functional Debian server using the expert guided installer and LVM for a flexible disk layout. Instructions: VM Creation: Create a new VM. Name it phoenix-server . Assign it: 2 vCPUs, 2048 MB RAM, and a new 20 GB virtual disk. Mount the Debian netinst ISO and boot the VM. Expert Installation: From the boot menu, select Advanced options > Expert install . This mode exposes every step of the installation process. Proceed through the initial steps (language, location, keyboard). Partitioning with LVM (The Core Task): When you reach the partitioning step, choose Manual . Create a new partition table on your virtual disk. Create a small 512MB primary partition at the beginning of the disk. Set its \"Use as\" type to Ext4 and its mount point to /boot . Create a second, larger primary partition using the remaining space. Set its \"Use as\" type to physical volume for LVM . Now, navigate to the \"Configure the Logical Volume Manager\" menu. Create a Volume Group (VG) named vg_phoenix . Inside vg_phoenix , create three Logical Volumes (LVs): lv_root : 10 GB, to be used for the root filesystem ( / ). lv_home : 5 GB, to be used for user data ( /home ). lv_swap : 2 GB, to be used for swap space. Finish the LVM configuration and assign each LV its filesystem type (Ext4 for root/home, swap for swap) and mount point. Minimal Package Installation: Proceed with the base system installation. When you reach \"Software selection,\" deselect everything , especially the \"Debian desktop environment.\" The only two options that should be checked are: SSH server standard system utilities This ensures our server is lean and has no unnecessary graphical components. Finalize and Verify: Install the GRUB bootloader to the primary drive (e.g., /dev/vda ). Finish the installation and reboot. The system will boot to a command-line interface. From your host machine's terminal, SSH into the new server ( ssh user@<vm_ip_address> ). Verification Commands: Run the following to confirm your setup. What does each one tell you? lsblk (Should show your LVM layout) df -h (Should show your filesystems mounted) free -m (Should show your swap space is active) dpkg --get-selections | wc -l (How many packages are installed? A minimal system is a happy system.)","title":"Level 1: The Foundation (Standard Complexity)"},{"location":"ucc111/labs/lab1/#level-2-the-optimization-advanced-complexity","text":"Goal: Harden the base installation, automate package deployment, and prepare it for a \"production\" role. Instructions: SSH Hardening: Modify /etc/ssh/sshd_config on phoenix-server to enhance security. Disable root login ( PermitRootLogin no ). Disable password-based authentication ( PasswordAuthentication no ). On your host machine, generate an SSH key ( ssh-keygen ) if you don't have one, and copy the public key to the server ( ssh-copy-id user@<vm_ip_address> ). Restart the SSH service ( systemctl restart sshd ) and verify you can still log in (it should now be passwordless). Firewall Configuration: Install the Uncomplicated Firewall: apt install ufw . Configure it to deny all incoming traffic by default. Explicitly allow SSH traffic. What port does SSH use? Enable the firewall. Verify its status. Create a Personal Package Repository: On the server, install nginx : apt install nginx . Create a simple dummy Debian package. You don't need to write code; the goal is to create the package structure. # Install packaging tools sudo apt install build-essential devscripts debhelper dh-make # Create a project mkdir ~/dummy-pkg-1.0 && cd ~/dummy-pkg-1.0 dh_make --native -s -y # Build the package (ignore warnings) debuild -us -uc - You will find a `.deb` file in the parent directory . - Create a directory in the `nginx` web root ( `/var/www/html/debian` ) and copy your `.deb` file there . - Configure `nginx` to serve this directory . - On the server itself , add your own `nginx` server as an APT repository in `/etc/apt/sources.list` . - Run `apt update` and then install your `dummy-pkg` .","title":"Level 2: The Optimization (Advanced Complexity)"},{"location":"ucc111/labs/lab1/#level-3-the-recovery-deep-dive-expert-complexity","text":"Goal: Simulate a catastrophic failure and rebuild the system without the installer, using only command-line tools. This is the ultimate test of system understanding. Instructions: Simulated Disaster: GRUB is Gone! On your working phoenix-server from Level 1, simulate a bootloader overwrite: sudo dd if=/dev/zero of=/dev/sda bs=446 count=1 Reboot the VM. It will fail to boot, likely with a \"No bootable medium\" error. The server is dead. Or is it? Manual System Rescue: Boot the VM using the Debian netinst ISO again. From the main menu, select Advanced options > Rescue mode . The rescue environment will try to find your existing installation. Let it guide you to mount your LVM root partition under /target . If it fails, you must do it manually using the provided shell. The key step: chroot /target . You are now inside your broken system, with the tools from the live CD. Your task: From within the chroot, fix the system. What commands do you need to run? You'll need to mount /boot . You'll need to reinstall GRUB. (Hint: grub-install /dev/sda1 ) You might need to update GRUB's configuration. Exit the chroot , reboot without the ISO, and watch your server rise from the ashes. The debootstrap Challenge: If you complete the rescue, the final challenge awaits. Destroy your VM and create a new one. This time, do not use the installer at all. Boot into Rescue Mode from the start. From the command line, perform a full manual installation: Partition the disk ( parted or fdisk ). Create the LVM structure ( pvcreate , vgcreate , lvcreate ). Format the filesystems ( mkfs.ext4 , mkswap ). Mount everything under /mnt (e.g., root on /mnt , boot on /mnt/boot ). Use debootstrap to install the Debian 'bookworm' release into /mnt . chroot into /mnt and manually install a kernel ( apt install linux-image-amd64 ), GRUB ( apt install grub-pc ), configure /etc/fstab , set a root password ( passwd ), and create a user. If you can successfully boot this manually-built system, you have demonstrated a true mastery of the Linux installation process.","title":"Level 3: The Recovery &amp; Deep Dive (Expert Complexity)"},{"location":"ucc121/","text":"This module covers the use of scripting to automate administrative tasks. Sections Scripting AI in Administration","title":"UCC121"},{"location":"ucc121/#sections","text":"Scripting AI in Administration","title":"Sections"},{"location":"ucc121/ai_in_admin/","text":"Course Information Sheet Title: AI In Administrative Tasks Code: UCC121-3 Prerequisites: UCC121-1 . Solid shell scripting skills. Duration: 12 hours (8 sessions of 1.5 hours each). Objectives: Use AI assistants to accelerate problem-solving and code generation. Apply AI to concrete use cases: log analysis, security, monitoring. Understand the principles of \"prompt engineering\" adapted to system tasks. Assessment: Continuous assessment (Practical Labs), project, final exam. 8-Session Breakdown Session 1: Introduction to AI for System Administration Lesson: What is an LLM? Overview of AI tools for the CLI. Potential, limitations, and ethical considerations. Lab/Assessment: Installation and configuration of a tool (e.g., GitHub Copilot for CLI). First simple prompts. Session 2: Command Generation and Explanation Lesson: The art of \"prompting\": how to translate a need into an effective AI query. Use cases: \"explain this command,\" \"find the command for...\". Lab/Assessment: Series of challenges to be solved using AI to find and understand complex commands ( find , rsync , iptables ). Session 3: AI-Assisted Script Generation Lesson: From a simple command to a complete script. How to specify the logic, error handling, and desired output format to the AI. Lab/Assessment: Generate a script that automates the creation of new users (with input validation). Session 4: Iterative Code Refinement and Debugging with AI Lesson: Using AI as a \"pair programming\" partner. Submitting an existing script to improve, refactor, or debug it. Lab/Assessment: Take a simple script and ask the AI to add logging, better error handling, and comments. Session 5: AI-Augmented Log Analysis Lesson: Strategies for analyzing large volumes of logs. Prompts for anomaly detection, activity summarization, and event correlation. Lab/Assessment: Analyze an auth.log to produce a security report (brute-force attempts, successful logins by user). Session 6: AI for Configuration and Security Lesson: Generate configuration files (Nginx, Apache, SSH). Audit an existing configuration with AI to identify potential security vulnerabilities. Lab/Assessment: Generate a secure Nginx configuration for a static website. Ask the AI to analyze sshd_config and suggest improvements. Session 7: Concepts of Predictive Monitoring Lesson: Introduction to AIOps. How AI can analyze metrics (CPU, RAM) to anticipate problems. Designing intelligent alerts. Lab/Assessment: Use AI to write the metric collection script. Discuss data analysis strategies for this data with the AI. Session 8: Synthesis Project and Future of AI Lesson: Reflection on the evolution of the system administrator profession. Lab/Assessment: Workshop dedicated to a final project combining scripting and AI (e.g., an intelligent system diagnostic tool) and presentation of results.","title":"AI in Administration"},{"location":"ucc121/ai_in_admin/#course-information-sheet","text":"Title: AI In Administrative Tasks Code: UCC121-3 Prerequisites: UCC121-1 . Solid shell scripting skills. Duration: 12 hours (8 sessions of 1.5 hours each). Objectives: Use AI assistants to accelerate problem-solving and code generation. Apply AI to concrete use cases: log analysis, security, monitoring. Understand the principles of \"prompt engineering\" adapted to system tasks. Assessment: Continuous assessment (Practical Labs), project, final exam.","title":"Course Information Sheet"},{"location":"ucc121/ai_in_admin/#8-session-breakdown","text":"","title":"8-Session Breakdown"},{"location":"ucc121/ai_in_admin/#session-1-introduction-to-ai-for-system-administration","text":"Lesson: What is an LLM? Overview of AI tools for the CLI. Potential, limitations, and ethical considerations. Lab/Assessment: Installation and configuration of a tool (e.g., GitHub Copilot for CLI). First simple prompts.","title":"Session 1: Introduction to AI for System Administration"},{"location":"ucc121/ai_in_admin/#session-2-command-generation-and-explanation","text":"Lesson: The art of \"prompting\": how to translate a need into an effective AI query. Use cases: \"explain this command,\" \"find the command for...\". Lab/Assessment: Series of challenges to be solved using AI to find and understand complex commands ( find , rsync , iptables ).","title":"Session 2: Command Generation and Explanation"},{"location":"ucc121/ai_in_admin/#session-3-ai-assisted-script-generation","text":"Lesson: From a simple command to a complete script. How to specify the logic, error handling, and desired output format to the AI. Lab/Assessment: Generate a script that automates the creation of new users (with input validation).","title":"Session 3: AI-Assisted Script Generation"},{"location":"ucc121/ai_in_admin/#session-4-iterative-code-refinement-and-debugging-with-ai","text":"Lesson: Using AI as a \"pair programming\" partner. Submitting an existing script to improve, refactor, or debug it. Lab/Assessment: Take a simple script and ask the AI to add logging, better error handling, and comments.","title":"Session 4: Iterative Code Refinement and Debugging with AI"},{"location":"ucc121/ai_in_admin/#session-5-ai-augmented-log-analysis","text":"Lesson: Strategies for analyzing large volumes of logs. Prompts for anomaly detection, activity summarization, and event correlation. Lab/Assessment: Analyze an auth.log to produce a security report (brute-force attempts, successful logins by user).","title":"Session 5: AI-Augmented Log Analysis"},{"location":"ucc121/ai_in_admin/#session-6-ai-for-configuration-and-security","text":"Lesson: Generate configuration files (Nginx, Apache, SSH). Audit an existing configuration with AI to identify potential security vulnerabilities. Lab/Assessment: Generate a secure Nginx configuration for a static website. Ask the AI to analyze sshd_config and suggest improvements.","title":"Session 6: AI for Configuration and Security"},{"location":"ucc121/ai_in_admin/#session-7-concepts-of-predictive-monitoring","text":"Lesson: Introduction to AIOps. How AI can analyze metrics (CPU, RAM) to anticipate problems. Designing intelligent alerts. Lab/Assessment: Use AI to write the metric collection script. Discuss data analysis strategies for this data with the AI.","title":"Session 7: Concepts of Predictive Monitoring"},{"location":"ucc121/ai_in_admin/#session-8-synthesis-project-and-future-of-ai","text":"Lesson: Reflection on the evolution of the system administrator profession. Lab/Assessment: Workshop dedicated to a final project combining scripting and AI (e.g., an intelligent system diagnostic tool) and presentation of results.","title":"Session 8: Synthesis Project and Future of AI"},{"location":"ucc121/labs/scripting_lab1/","text":"Exercise 1: Shell Script for Detecting and Removing Duplicate Files Objective: Write a shell script that compares the content of files in a specified directory to identify duplicates and optionally removes them. Requirements Input : The script should accept a directory path as an argument. Example: ./check-duplicates.sh /path/to/directory Output : The script should list all files in the directory with a column indicating whether they are duplicates. For duplicates, it should specify the file they match. Example: File | Duplicate -------------------------------- file1.txt | No file2.txt | Yes file3.txt | Yes (file2.txt) Optional Flag : Add a -fix flag to remove duplicate files. Only one copy of each duplicate file should be kept. Example: ./check-duplicates.sh /path/to/directory --fix # Deleting duplicate: file3.txt Implementation Details : Compare files based on their content. Use tools like md5sum or sha256sum to generate file hashes for comparison. Ensure the script handles different file sizes efficiently. Edge Cases : Handle empty directories gracefully. Display error messages for invalid directories or insufficient permissions. Evaluation Criteria Correctness : Does the script accurately identify duplicates? Does it correctly delete duplicates when -fix is provided? Code Quality : Is the script modular and easy to read? Does it make effective use of shell utilities (e.g., find , awk , sort )? Error Handling : Are invalid inputs handled gracefully? Are meaningful error messages displayed? Efficiency : Does the script process large directories effectively without excessive resource usage? Hints and Tips Use find to list files recursively in the directory. Use md5sum or sha256sum to calculate file hashes for comparison. Store hashes and file paths in a temporary file or an associative array for processing. Use awk or sed for formatting the output. Test your script with different types of files and directory structures.","title":"Lab 1 - Duplicate Files"},{"location":"ucc121/labs/scripting_lab1/#exercise-1-shell-script-for-detecting-and-removing-duplicate-files","text":"Objective: Write a shell script that compares the content of files in a specified directory to identify duplicates and optionally removes them.","title":"Exercise 1: Shell Script for Detecting and Removing Duplicate Files"},{"location":"ucc121/labs/scripting_lab1/#requirements","text":"Input : The script should accept a directory path as an argument. Example: ./check-duplicates.sh /path/to/directory Output : The script should list all files in the directory with a column indicating whether they are duplicates. For duplicates, it should specify the file they match. Example: File | Duplicate -------------------------------- file1.txt | No file2.txt | Yes file3.txt | Yes (file2.txt) Optional Flag : Add a -fix flag to remove duplicate files. Only one copy of each duplicate file should be kept. Example: ./check-duplicates.sh /path/to/directory --fix # Deleting duplicate: file3.txt Implementation Details : Compare files based on their content. Use tools like md5sum or sha256sum to generate file hashes for comparison. Ensure the script handles different file sizes efficiently. Edge Cases : Handle empty directories gracefully. Display error messages for invalid directories or insufficient permissions.","title":"Requirements"},{"location":"ucc121/labs/scripting_lab1/#evaluation-criteria","text":"Correctness : Does the script accurately identify duplicates? Does it correctly delete duplicates when -fix is provided? Code Quality : Is the script modular and easy to read? Does it make effective use of shell utilities (e.g., find , awk , sort )? Error Handling : Are invalid inputs handled gracefully? Are meaningful error messages displayed? Efficiency : Does the script process large directories effectively without excessive resource usage?","title":"Evaluation Criteria"},{"location":"ucc121/labs/scripting_lab1/#hints-and-tips","text":"Use find to list files recursively in the directory. Use md5sum or sha256sum to calculate file hashes for comparison. Store hashes and file paths in a temporary file or an associative array for processing. Use awk or sed for formatting the output. Test your script with different types of files and directory structures.","title":"Hints and Tips"},{"location":"ucc121/scripting/","text":"Course Information Sheet Title: Shells, Scripting, and Data Management Code: UCC121-1 Prerequisites: Basic proficiency with the Linux command line (UCC111 or equivalent). Duration: 12 hours (8 sessions of 1.5 hours each). Objectives: Master advanced command-line tools. Create robust and modular shell scripts for automation. Manipulate text data and interact with a simple database. Assessment: Continuous assessment (Practical Labs), scripting project, final exam. 8-Session Breakdown Session 1: Mastering the Shell Environment Lesson: Fundamentals of the Bash shell, customizing .bashrc , managing aliases, functions, and environment variables ( PATH , PS1 ). Lab/Assessment: Create useful aliases, write a function to automate a simple task (e.g., mkcd ), and customize the command prompt. Session 2: Text Processing Tools: grep , sed , awk Lesson: Introduction to regular expressions. Using grep for searching, sed for substitution, and awk for column extraction. Lab/Assessment: Extract all IP addresses from a log file. Replace a string in a series of configuration files. Session 3: Bash Scripting Fundamentals Lesson: Anatomy of a script (shebang, permissions), variables, reading user input ( read ), handling parameters ( $1 , $@ ), command substitution $(...) . Lab/Assessment: Write a script that takes a filename as a parameter and displays its first 3 lines. Session 4: Logic and Control Structures Lesson: if/elif/else conditions, file and string tests [[ ... ]] . The case statement. Handling exit codes ( $? ). Lab/Assessment: Write a script that checks if a user exists in /etc/passwd . Session 5: Loops and Iteration Lesson: for loops (over lists, sequences, files), while loops (to read a file line-by-line), and until loops. Lab/Assessment: Write a script that bulk renames all .jpeg files in a folder to .jpg . Session 6: Functions and Modularity Lesson: Declaring and calling functions, variable scope (local/global), passing arguments, and returning values. Sourcing function files. Lab/Assessment: Transform a monolithic script into a modular script using functions. Session 7: Introduction to Data Management with SQL Lesson: Principles of relational databases. Using sqlite3 for CREATE TABLE , INSERT , SELECT , UPDATE , DELETE . Lab/Assessment: Create a simple inventory database and write a shell script to query it. Session 8: Process Management and Automation with cron Lesson: Managing background jobs ( & , jobs , fg , bg , nohup ). Scheduling tasks with cron . Lab/Assessment: Launch a script as a background task. Schedule a backup script to run every night. Glossary of Terms awk : A powerful command-line tool for processing and analyzing column-based text data. alias : A custom shortcut for a longer command. Defined in shell configuration files. Bash (Bourne Again SHell) : The default command-line interpreter on most Linux systems. .bashrc : A script file that is executed every time a new interactive shell is started. Used for personal customizations. cron : A time-based job scheduler in Unix-like operating systems. Used to automate repetitive tasks. crontab : The file or command used to specify the schedule of cron jobs. Environment Variable : A dynamic named value that can affect the way running processes will behave on a computer. PATH and HOME are examples. grep : A command-line utility for searching plain-text data sets for lines that match a regular expression. function : A reusable block of code that is more powerful than an alias and can accept arguments. PATH : An environment variable specifying the set of directories where executable programs are located. PS1 : The primary prompt string environment variable, which controls the appearance of the command prompt. Regular Expression (Regex) : A sequence of characters that specifies a search pattern in text. sed : A \"stream editor\" utility for parsing and transforming text. Shebang ( #! ) : The first two characters of a script, which tell the system what interpreter to use to run it (e.g., #!/bin/bash ). Shell : A user interface for access to an operating system's services. In this context, a command-line interface (CLI). SQL (Structured Query Language) : A standard language for managing and manipulating data in relational databases. sqlite3 : A command-line interface to a self-contained, serverless, zero-configuration, transactional SQL database engine.","title":"Overview"},{"location":"ucc121/scripting/#course-information-sheet","text":"Title: Shells, Scripting, and Data Management Code: UCC121-1 Prerequisites: Basic proficiency with the Linux command line (UCC111 or equivalent). Duration: 12 hours (8 sessions of 1.5 hours each). Objectives: Master advanced command-line tools. Create robust and modular shell scripts for automation. Manipulate text data and interact with a simple database. Assessment: Continuous assessment (Practical Labs), scripting project, final exam.","title":"Course Information Sheet"},{"location":"ucc121/scripting/#8-session-breakdown","text":"","title":"8-Session Breakdown"},{"location":"ucc121/scripting/#session-1-mastering-the-shell-environment","text":"Lesson: Fundamentals of the Bash shell, customizing .bashrc , managing aliases, functions, and environment variables ( PATH , PS1 ). Lab/Assessment: Create useful aliases, write a function to automate a simple task (e.g., mkcd ), and customize the command prompt.","title":"Session 1: Mastering the Shell Environment"},{"location":"ucc121/scripting/#session-2-text-processing-tools-grep-sed-awk","text":"Lesson: Introduction to regular expressions. Using grep for searching, sed for substitution, and awk for column extraction. Lab/Assessment: Extract all IP addresses from a log file. Replace a string in a series of configuration files.","title":"Session 2: Text Processing Tools: grep, sed, awk"},{"location":"ucc121/scripting/#session-3-bash-scripting-fundamentals","text":"Lesson: Anatomy of a script (shebang, permissions), variables, reading user input ( read ), handling parameters ( $1 , $@ ), command substitution $(...) . Lab/Assessment: Write a script that takes a filename as a parameter and displays its first 3 lines.","title":"Session 3: Bash Scripting Fundamentals"},{"location":"ucc121/scripting/#session-4-logic-and-control-structures","text":"Lesson: if/elif/else conditions, file and string tests [[ ... ]] . The case statement. Handling exit codes ( $? ). Lab/Assessment: Write a script that checks if a user exists in /etc/passwd .","title":"Session 4: Logic and Control Structures"},{"location":"ucc121/scripting/#session-5-loops-and-iteration","text":"Lesson: for loops (over lists, sequences, files), while loops (to read a file line-by-line), and until loops. Lab/Assessment: Write a script that bulk renames all .jpeg files in a folder to .jpg .","title":"Session 5: Loops and Iteration"},{"location":"ucc121/scripting/#session-6-functions-and-modularity","text":"Lesson: Declaring and calling functions, variable scope (local/global), passing arguments, and returning values. Sourcing function files. Lab/Assessment: Transform a monolithic script into a modular script using functions.","title":"Session 6: Functions and Modularity"},{"location":"ucc121/scripting/#session-7-introduction-to-data-management-with-sql","text":"Lesson: Principles of relational databases. Using sqlite3 for CREATE TABLE , INSERT , SELECT , UPDATE , DELETE . Lab/Assessment: Create a simple inventory database and write a shell script to query it.","title":"Session 7: Introduction to Data Management with SQL"},{"location":"ucc121/scripting/#session-8-process-management-and-automation-with-cron","text":"Lesson: Managing background jobs ( & , jobs , fg , bg , nohup ). Scheduling tasks with cron . Lab/Assessment: Launch a script as a background task. Schedule a backup script to run every night.","title":"Session 8: Process Management and Automation with cron"},{"location":"ucc121/scripting/#glossary-of-terms","text":"awk : A powerful command-line tool for processing and analyzing column-based text data. alias : A custom shortcut for a longer command. Defined in shell configuration files. Bash (Bourne Again SHell) : The default command-line interpreter on most Linux systems. .bashrc : A script file that is executed every time a new interactive shell is started. Used for personal customizations. cron : A time-based job scheduler in Unix-like operating systems. Used to automate repetitive tasks. crontab : The file or command used to specify the schedule of cron jobs. Environment Variable : A dynamic named value that can affect the way running processes will behave on a computer. PATH and HOME are examples. grep : A command-line utility for searching plain-text data sets for lines that match a regular expression. function : A reusable block of code that is more powerful than an alias and can accept arguments. PATH : An environment variable specifying the set of directories where executable programs are located. PS1 : The primary prompt string environment variable, which controls the appearance of the command prompt. Regular Expression (Regex) : A sequence of characters that specifies a search pattern in text. sed : A \"stream editor\" utility for parsing and transforming text. Shebang ( #! ) : The first two characters of a script, which tell the system what interpreter to use to run it (e.g., #!/bin/bash ). Shell : A user interface for access to an operating system's services. In this context, a command-line interface (CLI). SQL (Structured Query Language) : A standard language for managing and manipulating data in relational databases. sqlite3 : A command-line interface to a self-contained, serverless, zero-configuration, transactional SQL database engine.","title":"Glossary of Terms"},{"location":"ucc121/scripting/session1/","text":"Topic: Mastering the Shell Environment 1. What is a Shell? A shell is a program that provides the user with a direct interface to the operating system. It takes your commands, interprets them, and asks the operating system to perform the requested action. Interface: It's a Command-Line Interface (CLI). Role: Sits between you (the user) and the operating system's core (the kernel ). Default Shell: On most Linux systems, the default shell is bash (the B ourne A gain SH ell). You can find out what shell you are using with the command: echo $SHELL 2. The .bashrc File: Your Personal Toolbox When you start an interactive shell, it automatically runs a script to set up your environment. This script is .bashrc (located in your home directory, ~/.bashrc ). Purpose: To store all your personal customizations: aliases, functions, and environment variables. Activation: Changes made to .bashrc are not applied automatically to your current session. You must load them by either: Starting a new shell session. Running the command source ~/.bashrc . 3. Aliases: Your Command-Line Shortcuts An alias is a simple way to create a shortcut for a longer command. They are perfect for commands you use often. Syntax: alias shortcut_name='the_long_command' Common & Useful Examples: # Make 'ls' more informative and colorful alias ls = 'ls --color=auto' alias ll = 'ls -alF' alias la = 'ls -A' alias l = 'ls -CF' # Shortcuts for system updates (Debian/Ubuntu) alias update = 'sudo apt update && sudo apt upgrade' # Show open ports alias ports = 'netstat -tulpn' How to add them: Open ~/.bashrc with a text editor (like nano or vim ) and add these lines. Then run source ~/.bashrc . Removing an alias: unalias shortcut_name 4. Functions: Super-Powered Aliases Functions are like aliases, but they are more powerful. They can accept arguments (parameters), contain multiple commands, and use logic. Syntax: function_name () { # command 1 # command 2 # use $1, $2 for arguments } Example: The mkcd function A common task is to create a directory and then immediately navigate into it. Problem: mkdir new_dir followed by cd new_dir . Solution: A function that does both! # Creates a directory and changes into it mkcd () { mkdir -p \" $1 \" && cd \" $1 \" } mkdir -p \"$1\" : Creates the directory. -p ensures it doesn't fail if the directory exists and also creates parent directories if needed. \"$1\" is the first argument you provide to the function. && : This is a logical AND. The cd \"$1\" command only runs if the mkdir command was successful. 5. Environment Variables: The Shell's Memory Environment variables are dynamic values that affect the processes and programs running in the shell. By convention, their names are in uppercase. Key Variables to Know: PATH What it is: A colon-separated list of directories that the shell searches through when you type a command. How it works: When you type ls , the shell looks for an executable file named ls in each directory listed in $PATH . View it: echo $PATH Modify it: To add a custom scripts folder (e.g., ~/bin ) to your PATH, you would add this to .bashrc : export PATH=\"$HOME/bin:$PATH\" This tells the shell to look in ~/bin` first, then in all the other standard locations. PS1 What it is: The Primary Prompt String. This variable controls what your command prompt looks like. Customization: You can use special backslash-escaped characters to insert dynamic information. View it: echo $PS1 Common PS1 codes: \\u : Username \\h : Hostname (the computer's name) \\w : The current working directory \\t : The current time (HH:MM:SS) \\$ : Displays a # if you are the root user, $ otherwise. Example PS1 Customization: # A prompt showing user@host:directory export PS1 = '[\\u@\\h \\w]\\$ ' # A prompt with colors (this can look complex!) export PS1 = '[\\033[01;32m\\]\\u@\\h[\\033[00m]:[\\033[01;34m\\]\\w[\\033[00m]\\$ ' 6. Lab Exercises (TP/CC) Open ~/.bashrc : Use a text editor like nano ~/.bashrc . Add Aliases: Add the ll and update aliases shown in the examples above. Add a Function: Add the mkcd function. Customize your Prompt: Add the colored PS1 export line from the example. Activate Changes: Save the file and run source ~/.bashrc . Test Everything: Type ll . Does it show a detailed file listing? Type type update . Does it show that update is an alias? Use your new mkcd function: mkcd test_directory . Did it create the folder and move you inside it? Does your prompt look different and colorful?","title":"Mastering the Shell Environment"},{"location":"ucc121/scripting/session1/#topic-mastering-the-shell-environment","text":"","title":"Topic: Mastering the Shell Environment"},{"location":"ucc121/scripting/session1/#1-what-is-a-shell","text":"A shell is a program that provides the user with a direct interface to the operating system. It takes your commands, interprets them, and asks the operating system to perform the requested action. Interface: It's a Command-Line Interface (CLI). Role: Sits between you (the user) and the operating system's core (the kernel ). Default Shell: On most Linux systems, the default shell is bash (the B ourne A gain SH ell). You can find out what shell you are using with the command: echo $SHELL","title":"1. What is a Shell?"},{"location":"ucc121/scripting/session1/#2-the-bashrc-file-your-personal-toolbox","text":"When you start an interactive shell, it automatically runs a script to set up your environment. This script is .bashrc (located in your home directory, ~/.bashrc ). Purpose: To store all your personal customizations: aliases, functions, and environment variables. Activation: Changes made to .bashrc are not applied automatically to your current session. You must load them by either: Starting a new shell session. Running the command source ~/.bashrc .","title":"2. The .bashrc File: Your Personal Toolbox"},{"location":"ucc121/scripting/session1/#3-aliases-your-command-line-shortcuts","text":"An alias is a simple way to create a shortcut for a longer command. They are perfect for commands you use often. Syntax: alias shortcut_name='the_long_command' Common & Useful Examples: # Make 'ls' more informative and colorful alias ls = 'ls --color=auto' alias ll = 'ls -alF' alias la = 'ls -A' alias l = 'ls -CF' # Shortcuts for system updates (Debian/Ubuntu) alias update = 'sudo apt update && sudo apt upgrade' # Show open ports alias ports = 'netstat -tulpn' How to add them: Open ~/.bashrc with a text editor (like nano or vim ) and add these lines. Then run source ~/.bashrc . Removing an alias: unalias shortcut_name","title":"3. Aliases: Your Command-Line Shortcuts"},{"location":"ucc121/scripting/session1/#4-functions-super-powered-aliases","text":"Functions are like aliases, but they are more powerful. They can accept arguments (parameters), contain multiple commands, and use logic. Syntax: function_name () { # command 1 # command 2 # use $1, $2 for arguments } Example: The mkcd function A common task is to create a directory and then immediately navigate into it. Problem: mkdir new_dir followed by cd new_dir . Solution: A function that does both! # Creates a directory and changes into it mkcd () { mkdir -p \" $1 \" && cd \" $1 \" } mkdir -p \"$1\" : Creates the directory. -p ensures it doesn't fail if the directory exists and also creates parent directories if needed. \"$1\" is the first argument you provide to the function. && : This is a logical AND. The cd \"$1\" command only runs if the mkdir command was successful.","title":"4. Functions: Super-Powered Aliases"},{"location":"ucc121/scripting/session1/#5-environment-variables-the-shells-memory","text":"Environment variables are dynamic values that affect the processes and programs running in the shell. By convention, their names are in uppercase. Key Variables to Know:","title":"5. Environment Variables: The Shell's Memory"},{"location":"ucc121/scripting/session1/#path","text":"What it is: A colon-separated list of directories that the shell searches through when you type a command. How it works: When you type ls , the shell looks for an executable file named ls in each directory listed in $PATH . View it: echo $PATH Modify it: To add a custom scripts folder (e.g., ~/bin ) to your PATH, you would add this to .bashrc : export PATH=\"$HOME/bin:$PATH\" This tells the shell to look in ~/bin` first, then in all the other standard locations.","title":"PATH"},{"location":"ucc121/scripting/session1/#ps1","text":"What it is: The Primary Prompt String. This variable controls what your command prompt looks like. Customization: You can use special backslash-escaped characters to insert dynamic information. View it: echo $PS1 Common PS1 codes: \\u : Username \\h : Hostname (the computer's name) \\w : The current working directory \\t : The current time (HH:MM:SS) \\$ : Displays a # if you are the root user, $ otherwise. Example PS1 Customization: # A prompt showing user@host:directory export PS1 = '[\\u@\\h \\w]\\$ ' # A prompt with colors (this can look complex!) export PS1 = '[\\033[01;32m\\]\\u@\\h[\\033[00m]:[\\033[01;34m\\]\\w[\\033[00m]\\$ '","title":"PS1"},{"location":"ucc121/scripting/session1/#6-lab-exercises-tpcc","text":"Open ~/.bashrc : Use a text editor like nano ~/.bashrc . Add Aliases: Add the ll and update aliases shown in the examples above. Add a Function: Add the mkcd function. Customize your Prompt: Add the colored PS1 export line from the example. Activate Changes: Save the file and run source ~/.bashrc . Test Everything: Type ll . Does it show a detailed file listing? Type type update . Does it show that update is an alias? Use your new mkcd function: mkcd test_directory . Did it create the folder and move you inside it? Does your prompt look different and colorful?","title":"6. Lab Exercises (TP/CC)"},{"location":"ucc121/scripting/session2/","text":"Topic: From User to Creator - Writing Your First Scripts 1. The Anatomy of a Script In Session 1, we customized our environment. Now, we will write standalone programs. A shell script is simply a text file containing a sequence of commands that the shell executes for you. The \"Shebang\" ( #! ) Every script should start with a specific line called the shebang . It tells the system which interpreter should be used to execute the file. #!/bin/bash #! : The magic bytes that mark the file as a script. /bin/bash : The path to the interpreter. Pro Tip: While #!/bin/sh exists, it is often a stricter, POSIX-compliant shell. We use #!/bin/bash to unlock modern features like arrays and better string handling. Comments Comments are lines ignored by the shell, starting with # . Use them to explain why your code does something, not what it does. #!/bin/bash # This script greets the user # Author: Marco echo \"Hello, World!\" 2. Making it Executable Creating the file isn't enough. Linux has a permission model that prevents text files from being executed as programs by default. The Command: chmod (Change Mode) chmod +x my_script.sh +x : Adds eXecutable permission. Running the Script: Once executable, you run it by specifying its path: ./my_script.sh Why ./ ? Because for security reasons, the current directory ( . ) is usually not in your $PATH . You must explicitly tell the shell \"run the file right here \". 3. Variables & Quoting: The \"Gotchas\" In scripting, how you handle text matters immensely. Defining and Using Variables name = \"Alice\" # No spaces around the = sign! echo \"Hello, $name \" The Quote War: \" vs ' This is the most common source of bugs for beginners. Double Quotes ( \" ): \"Weak\" quoting. Variables ( $name ) are expanded (replaced with their value). Single Quotes ( ' ): \"Strong\" quoting. Everything inside is treated literally. No expansion happens. Example: user = \"Bob\" echo \"My name is $user \" # Output: My name is Bob echo 'My name is $user' # Output: My name is $user 4. Interactivity with read Scripts are boring if they don't talk to you. The read command pauses execution to get input from the keyboard. echo \"What is your project name?\" read project_name echo \"Creating project: $project_name ...\" mkdir \" $project_name \" Optimization: You can provide a prompt directly inside read : read -p \"Enter username: \" user_var 5. Exit Codes: The Language of Success Every command in Linux returns a status code when it finishes. - 0 : Success. - 1-255 : Error. You can access the exit code of the last command run using the special variable $? . mkdir new_folder echo \"The exit code was: $? \" If new_folder didn't exist, mkdir succeeds (0). If it already existed, mkdir fails (1), and $? will hold 1 . We can use this to make our scripts smart (which we will cover in depth in Session 3 with if statements). 6. Command Substitution Sometimes you want to save the output of a command into a variable. We use the $() syntax. # Save the current date into a variable current_date = $( date +%F ) # Save the number of files in the current dir file_count = $( ls | wc -l ) echo \"Report for $current_date : Found $file_count files.\" History Lesson: You might see backticks `date` in old tutorials. Avoid them. $() is nestable and cleaner. Lab Exercises (TP) Goal: Create a \"New Project Generator\" script. Create a file named start_project.sh . Add the Shebang. Ask the user for a Project Name . Ask the user for an Author Name . Create a folder with the Project Name. Inside that folder, create a README.md file. Write the text \"Project: [Name] created by [Author]\" into the README.md . Make the script executable and run it. Bonus: Display \"Success! Project created at [Path]\" using the pwd command substitution. External Resources ShellCheck.net : The absolute best tool for finding bugs in your scripts. Paste your code there! Explainshell.com : Type a command line to see a visual breakdown of what each flag does.","title":"Introduction to Scripting"},{"location":"ucc121/scripting/session2/#topic-from-user-to-creator-writing-your-first-scripts","text":"","title":"Topic: From User to Creator - Writing Your First Scripts"},{"location":"ucc121/scripting/session2/#1-the-anatomy-of-a-script","text":"In Session 1, we customized our environment. Now, we will write standalone programs. A shell script is simply a text file containing a sequence of commands that the shell executes for you.","title":"1. The Anatomy of a Script"},{"location":"ucc121/scripting/session2/#the-shebang","text":"Every script should start with a specific line called the shebang . It tells the system which interpreter should be used to execute the file. #!/bin/bash #! : The magic bytes that mark the file as a script. /bin/bash : The path to the interpreter. Pro Tip: While #!/bin/sh exists, it is often a stricter, POSIX-compliant shell. We use #!/bin/bash to unlock modern features like arrays and better string handling.","title":"The \"Shebang\" (#!)"},{"location":"ucc121/scripting/session2/#comments","text":"Comments are lines ignored by the shell, starting with # . Use them to explain why your code does something, not what it does. #!/bin/bash # This script greets the user # Author: Marco echo \"Hello, World!\"","title":"Comments"},{"location":"ucc121/scripting/session2/#2-making-it-executable","text":"Creating the file isn't enough. Linux has a permission model that prevents text files from being executed as programs by default. The Command: chmod (Change Mode) chmod +x my_script.sh +x : Adds eXecutable permission. Running the Script: Once executable, you run it by specifying its path: ./my_script.sh Why ./ ? Because for security reasons, the current directory ( . ) is usually not in your $PATH . You must explicitly tell the shell \"run the file right here \".","title":"2. Making it Executable"},{"location":"ucc121/scripting/session2/#3-variables-quoting-the-gotchas","text":"In scripting, how you handle text matters immensely.","title":"3. Variables &amp; Quoting: The \"Gotchas\""},{"location":"ucc121/scripting/session2/#defining-and-using-variables","text":"name = \"Alice\" # No spaces around the = sign! echo \"Hello, $name \"","title":"Defining and Using Variables"},{"location":"ucc121/scripting/session2/#the-quote-war-vs","text":"This is the most common source of bugs for beginners. Double Quotes ( \" ): \"Weak\" quoting. Variables ( $name ) are expanded (replaced with their value). Single Quotes ( ' ): \"Strong\" quoting. Everything inside is treated literally. No expansion happens. Example: user = \"Bob\" echo \"My name is $user \" # Output: My name is Bob echo 'My name is $user' # Output: My name is $user","title":"The Quote War: \" vs '"},{"location":"ucc121/scripting/session2/#4-interactivity-with-read","text":"Scripts are boring if they don't talk to you. The read command pauses execution to get input from the keyboard. echo \"What is your project name?\" read project_name echo \"Creating project: $project_name ...\" mkdir \" $project_name \" Optimization: You can provide a prompt directly inside read : read -p \"Enter username: \" user_var","title":"4. Interactivity with read"},{"location":"ucc121/scripting/session2/#5-exit-codes-the-language-of-success","text":"Every command in Linux returns a status code when it finishes. - 0 : Success. - 1-255 : Error. You can access the exit code of the last command run using the special variable $? . mkdir new_folder echo \"The exit code was: $? \" If new_folder didn't exist, mkdir succeeds (0). If it already existed, mkdir fails (1), and $? will hold 1 . We can use this to make our scripts smart (which we will cover in depth in Session 3 with if statements).","title":"5. Exit Codes: The Language of Success"},{"location":"ucc121/scripting/session2/#6-command-substitution","text":"Sometimes you want to save the output of a command into a variable. We use the $() syntax. # Save the current date into a variable current_date = $( date +%F ) # Save the number of files in the current dir file_count = $( ls | wc -l ) echo \"Report for $current_date : Found $file_count files.\" History Lesson: You might see backticks `date` in old tutorials. Avoid them. $() is nestable and cleaner.","title":"6. Command Substitution"},{"location":"ucc121/scripting/session2/#lab-exercises-tp","text":"Goal: Create a \"New Project Generator\" script. Create a file named start_project.sh . Add the Shebang. Ask the user for a Project Name . Ask the user for an Author Name . Create a folder with the Project Name. Inside that folder, create a README.md file. Write the text \"Project: [Name] created by [Author]\" into the README.md . Make the script executable and run it. Bonus: Display \"Success! Project created at [Path]\" using the pwd command substitution.","title":"Lab Exercises (TP)"},{"location":"ucc121/scripting/session2/#external-resources","text":"ShellCheck.net : The absolute best tool for finding bugs in your scripts. Paste your code there! Explainshell.com : Type a command line to see a visual breakdown of what each flag does.","title":"External Resources"},{"location":"ucc141/","text":"This module covers virtualization fundamentals. Sections UCC141-1: Virtualization Fundamentals","title":"UCC141"},{"location":"ucc141/#sections","text":"UCC141-1: Virtualization Fundamentals","title":"Sections"},{"location":"ucc141/virtualization_fundamentals/","text":"Course Information Sheet Title: Virtualization Fundamentals Code: UCC141-1 Prerequisites: None. Basic computer literacy is assumed. Duration: 12 hours (8 sessions of 1.5 hours each). Objectives: Understand the core concepts of hypervisor-based virtualization. Gain practical skills to create, configure, and manage virtual machines (VMs). Learn to manage VM states and networking for various use cases. Assessment: Continuous assessment (Practical Labs), final exam. 8-Session Breakdown Session 1: Introduction to Virtualization Lesson: What is virtualization? Key concepts (Host vs. Guest), benefits (consolidation, isolation, portability), and common use cases (development, testing, servers). A brief history of virtualization. Lab/Assessment: Research and compare three different virtualization solutions available today (e.g., VMware, KVM, Hyper-V). Session 2: Hypervisors Deep Dive Lesson: Understanding the role of the hypervisor. In-depth comparison of Type 1 (Bare-metal) and Type 2 (Hosted) hypervisors. Lab/Assessment: Install VirtualBox on a host machine and explore its global settings and preferences. Session 3: Creating Your First Virtual Machine Lesson: Step-by-step walkthrough of the VM creation wizard. Allocating virtual hardware (CPU, RAM). Creating and attaching a virtual hard disk. Mounting an ISO image for OS installation. Lab/Assessment: Create a new VM and install a lightweight Linux distribution (e.g., Lubuntu or Debian Netinstall). Session 4: VM Hardware and Configuration Lesson: Modifying VM settings. Understanding different virtual disk formats (VDI, VMDK, QCOW2) and their characteristics (fixed vs. dynamically allocated). Lab/Assessment: Add a second virtual hard disk to your VM. Resize the RAM and CPU allocation and observe the performance impact. Session 5: Virtual Networking Lesson: Exploring different virtual network modes: NAT, Bridged, Host-Only, and Internal Networking. Understanding the use case for each mode. Lab/Assessment: Configure two VMs. One in Host-Only mode to communicate only with the host, and another in Bridged mode to get an IP from the local network. Verify connectivity. Session 6: Snapshots for State Management Lesson: The power of snapshots. How to create, revert to, and delete snapshots. Understanding the snapshot tree and potential pitfalls. Lab/Assessment: On your Linux VM, install a web server. Take a snapshot. \"Break\" the web server configuration. Revert to the snapshot to restore functionality. Session 7: Cloning and Templates Lesson: Creating copies of VMs. Full clones vs. Linked clones: understanding the difference in disk usage and independence. Using a master VM as a template. Lab/Assessment: Create a \"master\" Linux VM. Create one full clone and one linked clone from it. Verify that they all run independently. Session 8: Automation and Portability Lesson: Introduction to VM automation with tools like Vagrant. Understanding the Vagrantfile . The importance of importing/exporting VMs in the Open Virtualization Format (OVF). Lab/Assessment: Install Vagrant. Use a public Vagrant box to spin up a pre-configured VM with a single command ( vagrant up ). Glossary of Terms Cloning : The process of creating an exact copy of a virtual machine. A full clone is an independent copy, while a linked clone depends on the original VM. Guest OS : The operating system running inside a virtual machine. Host OS : The operating system running on the physical computer where the hypervisor is installed. Hypervisor : The software that creates and runs virtual machines. Type 1 runs directly on the host's hardware, while Type 2 runs on a conventional operating system. ISO Image : A file containing the complete contents of an optical disc (CD, DVD, etc.), often used to install operating systems on VMs. KVM (Kernel-based Virtual Machine) : A Type 1 hypervisor built into the Linux kernel. NAT (Network Address Translation) : A virtual network mode where the VM shares the host's IP address and is typically not directly accessible from the external network. Bridged Networking : A virtual network mode that connects the VM to the physical network as if it were another physical machine, getting its own IP address. Host-Only Networking : A virtual network mode that creates a private network between the host and its VMs, with no external access. Snapshot : A saved state of a virtual machine at a specific point in time, including its memory, settings, and disk state. Vagrant : A tool for building and managing virtual machine environments in a single workflow, often used for development environments. Virtual Machine (VM) : A software-based emulation of a physical computer that can run its own operating system and applications. Virtual Disk : A file on a host file system that appears as a physical hard disk to a guest operating system (e.g., VDI, VMDK files). VirtualBox : A popular, cross-platform Type 2 hypervisor for desktop use.","title":"Overview"},{"location":"ucc141/virtualization_fundamentals/#course-information-sheet","text":"Title: Virtualization Fundamentals Code: UCC141-1 Prerequisites: None. Basic computer literacy is assumed. Duration: 12 hours (8 sessions of 1.5 hours each). Objectives: Understand the core concepts of hypervisor-based virtualization. Gain practical skills to create, configure, and manage virtual machines (VMs). Learn to manage VM states and networking for various use cases. Assessment: Continuous assessment (Practical Labs), final exam.","title":"Course Information Sheet"},{"location":"ucc141/virtualization_fundamentals/#8-session-breakdown","text":"","title":"8-Session Breakdown"},{"location":"ucc141/virtualization_fundamentals/#session-1-introduction-to-virtualization","text":"Lesson: What is virtualization? Key concepts (Host vs. Guest), benefits (consolidation, isolation, portability), and common use cases (development, testing, servers). A brief history of virtualization. Lab/Assessment: Research and compare three different virtualization solutions available today (e.g., VMware, KVM, Hyper-V).","title":"Session 1: Introduction to Virtualization"},{"location":"ucc141/virtualization_fundamentals/#session-2-hypervisors-deep-dive","text":"Lesson: Understanding the role of the hypervisor. In-depth comparison of Type 1 (Bare-metal) and Type 2 (Hosted) hypervisors. Lab/Assessment: Install VirtualBox on a host machine and explore its global settings and preferences.","title":"Session 2: Hypervisors Deep Dive"},{"location":"ucc141/virtualization_fundamentals/#session-3-creating-your-first-virtual-machine","text":"Lesson: Step-by-step walkthrough of the VM creation wizard. Allocating virtual hardware (CPU, RAM). Creating and attaching a virtual hard disk. Mounting an ISO image for OS installation. Lab/Assessment: Create a new VM and install a lightweight Linux distribution (e.g., Lubuntu or Debian Netinstall).","title":"Session 3: Creating Your First Virtual Machine"},{"location":"ucc141/virtualization_fundamentals/#session-4-vm-hardware-and-configuration","text":"Lesson: Modifying VM settings. Understanding different virtual disk formats (VDI, VMDK, QCOW2) and their characteristics (fixed vs. dynamically allocated). Lab/Assessment: Add a second virtual hard disk to your VM. Resize the RAM and CPU allocation and observe the performance impact.","title":"Session 4: VM Hardware and Configuration"},{"location":"ucc141/virtualization_fundamentals/#session-5-virtual-networking","text":"Lesson: Exploring different virtual network modes: NAT, Bridged, Host-Only, and Internal Networking. Understanding the use case for each mode. Lab/Assessment: Configure two VMs. One in Host-Only mode to communicate only with the host, and another in Bridged mode to get an IP from the local network. Verify connectivity.","title":"Session 5: Virtual Networking"},{"location":"ucc141/virtualization_fundamentals/#session-6-snapshots-for-state-management","text":"Lesson: The power of snapshots. How to create, revert to, and delete snapshots. Understanding the snapshot tree and potential pitfalls. Lab/Assessment: On your Linux VM, install a web server. Take a snapshot. \"Break\" the web server configuration. Revert to the snapshot to restore functionality.","title":"Session 6: Snapshots for State Management"},{"location":"ucc141/virtualization_fundamentals/#session-7-cloning-and-templates","text":"Lesson: Creating copies of VMs. Full clones vs. Linked clones: understanding the difference in disk usage and independence. Using a master VM as a template. Lab/Assessment: Create a \"master\" Linux VM. Create one full clone and one linked clone from it. Verify that they all run independently.","title":"Session 7: Cloning and Templates"},{"location":"ucc141/virtualization_fundamentals/#session-8-automation-and-portability","text":"Lesson: Introduction to VM automation with tools like Vagrant. Understanding the Vagrantfile . The importance of importing/exporting VMs in the Open Virtualization Format (OVF). Lab/Assessment: Install Vagrant. Use a public Vagrant box to spin up a pre-configured VM with a single command ( vagrant up ).","title":"Session 8: Automation and Portability"},{"location":"ucc141/virtualization_fundamentals/#glossary-of-terms","text":"Cloning : The process of creating an exact copy of a virtual machine. A full clone is an independent copy, while a linked clone depends on the original VM. Guest OS : The operating system running inside a virtual machine. Host OS : The operating system running on the physical computer where the hypervisor is installed. Hypervisor : The software that creates and runs virtual machines. Type 1 runs directly on the host's hardware, while Type 2 runs on a conventional operating system. ISO Image : A file containing the complete contents of an optical disc (CD, DVD, etc.), often used to install operating systems on VMs. KVM (Kernel-based Virtual Machine) : A Type 1 hypervisor built into the Linux kernel. NAT (Network Address Translation) : A virtual network mode where the VM shares the host's IP address and is typically not directly accessible from the external network. Bridged Networking : A virtual network mode that connects the VM to the physical network as if it were another physical machine, getting its own IP address. Host-Only Networking : A virtual network mode that creates a private network between the host and its VMs, with no external access. Snapshot : A saved state of a virtual machine at a specific point in time, including its memory, settings, and disk state. Vagrant : A tool for building and managing virtual machine environments in a single workflow, often used for development environments. Virtual Machine (VM) : A software-based emulation of a physical computer that can run its own operating system and applications. Virtual Disk : A file on a host file system that appears as a physical hard disk to a guest operating system (e.g., VDI, VMDK files). VirtualBox : A popular, cross-platform Type 2 hypervisor for desktop use.","title":"Glossary of Terms"},{"location":"ucc141/virtualization_fundamentals/session2/","text":"Topic: Hypervisors Deep Dive 1. Understanding the Hypervisor The hypervisor , also known as the Virtual Machine Monitor (VMM) , is the critical layer of software that makes virtualization possible. Role: It sits between the physical hardware and the virtual machines. Function: It creates a virtualization layer that abstracts the physical hardware resources (CPU, Memory, Storage) and distributes them to the VMs. Isolation: It ensures that VMs are isolated from each other and from the host system, so a crash in one VM does not affect others. 2. Type 1 Hypervisors (Bare-Metal) Type 1 hypervisors are installed directly on the physical server's hardware . There is no underlying operating system required to run them. Structure: Hardware -> Hypervisor -> Virtual Machines. Performance: High. They have direct access to hardware and act as their own operating system, managing and scheduling resources directly. Use Case: Enterprise data centers, cloud infrastructure (AWS, Azure), large-scale server consolidation. Examples: VMware ESXi Microsoft Hyper-V (Server) Xen KVM (Kernel-based Virtual Machine) - Note: KVM turns the Linux kernel itself into a Type 1 hypervisor. 3. Type 2 Hypervisors (Hosted) Type 2 hypervisors run as an application on top of a conventional operating system (the Host OS ). Structure: Hardware -> Host OS -> Hypervisor App -> Virtual Machines. Performance: Lower than Type 1. The hypervisor does not have direct hardware access. All hardware requests, including CPU and memory access, must be passed to the Host OS's scheduler first. This extra layer of translation adds overhead and latency. Use Case: Desktop virtualization, development/testing environments, running a second OS on your laptop. Examples: Oracle VirtualBox VMware Workstation Pro / Player Parallels Desktop (for Mac) 4. CPU Architecture: A Critical Foundation Virtualization is not magic; it relies on the host CPU's architecture. The guest operating system's architecture must be compatible with the host's. x86-64 (or amd64): The dominant architecture for modern desktops, laptops, and servers. You can virtualize 64-bit (x86-64) and 32-bit (x86) operating systems on a standard 64-bit computer. ARM: The architecture for most mobile devices and Apple Silicon Macs. You cannot directly virtualize an x86 OS on an ARM host. This requires emulation , a much slower process where every CPU instruction is translated in software. Key Takeaway: Virtualization shares hardware. Emulation fakes it. 5. Comparison: Type 1 vs. Type 2 Feature Type 1 (Bare-Metal) Type 2 (Hosted) Hardware Access Direct Indirect (via Host OS) Performance Native / High Slower (due to OS overhead) Scalability High Low to Medium Management Often remote (web console/CLI) Local GUI Application Typical User IT Administrator Developer / End User 6. Introduction to VirtualBox For this course, we will use Oracle VM VirtualBox , a popular open-source Type 2 hypervisor. Cross-Platform: Runs on Windows, Linux, and macOS hosts. Key Components: VirtualBox Manager: The GUI for creating and managing VMs. VBoxManage: A powerful CLI tool for advanced management. Extension Pack: Adds features like USB 2.0/3.0 support, VRDP (Virtual Remote Desktop Protocol), and other advanced capabilities. 7. Lab Exercises (TP/CC) Installation: Download and install VirtualBox on your workstation. Optional but Recommended: Install the VirtualBox Extension Pack. Explore Global Preferences: Open VirtualBox and go to File > Preferences . Check the Default Machine Folder . Ensure this drive has plenty of free space. Network Host Manager: Go to File > Tools > Network Manager . Observe any \"Host-Only Ethernet Adapters\" listed. We will use these in future sessions.","title":"Hypervisors Deep Dive"},{"location":"ucc141/virtualization_fundamentals/session2/#topic-hypervisors-deep-dive","text":"","title":"Topic: Hypervisors Deep Dive"},{"location":"ucc141/virtualization_fundamentals/session2/#1-understanding-the-hypervisor","text":"The hypervisor , also known as the Virtual Machine Monitor (VMM) , is the critical layer of software that makes virtualization possible. Role: It sits between the physical hardware and the virtual machines. Function: It creates a virtualization layer that abstracts the physical hardware resources (CPU, Memory, Storage) and distributes them to the VMs. Isolation: It ensures that VMs are isolated from each other and from the host system, so a crash in one VM does not affect others.","title":"1. Understanding the Hypervisor"},{"location":"ucc141/virtualization_fundamentals/session2/#2-type-1-hypervisors-bare-metal","text":"Type 1 hypervisors are installed directly on the physical server's hardware . There is no underlying operating system required to run them. Structure: Hardware -> Hypervisor -> Virtual Machines. Performance: High. They have direct access to hardware and act as their own operating system, managing and scheduling resources directly. Use Case: Enterprise data centers, cloud infrastructure (AWS, Azure), large-scale server consolidation. Examples: VMware ESXi Microsoft Hyper-V (Server) Xen KVM (Kernel-based Virtual Machine) - Note: KVM turns the Linux kernel itself into a Type 1 hypervisor.","title":"2. Type 1 Hypervisors (Bare-Metal)"},{"location":"ucc141/virtualization_fundamentals/session2/#3-type-2-hypervisors-hosted","text":"Type 2 hypervisors run as an application on top of a conventional operating system (the Host OS ). Structure: Hardware -> Host OS -> Hypervisor App -> Virtual Machines. Performance: Lower than Type 1. The hypervisor does not have direct hardware access. All hardware requests, including CPU and memory access, must be passed to the Host OS's scheduler first. This extra layer of translation adds overhead and latency. Use Case: Desktop virtualization, development/testing environments, running a second OS on your laptop. Examples: Oracle VirtualBox VMware Workstation Pro / Player Parallels Desktop (for Mac)","title":"3. Type 2 Hypervisors (Hosted)"},{"location":"ucc141/virtualization_fundamentals/session2/#4-cpu-architecture-a-critical-foundation","text":"Virtualization is not magic; it relies on the host CPU's architecture. The guest operating system's architecture must be compatible with the host's. x86-64 (or amd64): The dominant architecture for modern desktops, laptops, and servers. You can virtualize 64-bit (x86-64) and 32-bit (x86) operating systems on a standard 64-bit computer. ARM: The architecture for most mobile devices and Apple Silicon Macs. You cannot directly virtualize an x86 OS on an ARM host. This requires emulation , a much slower process where every CPU instruction is translated in software. Key Takeaway: Virtualization shares hardware. Emulation fakes it.","title":"4. CPU Architecture: A Critical Foundation"},{"location":"ucc141/virtualization_fundamentals/session2/#5-comparison-type-1-vs-type-2","text":"Feature Type 1 (Bare-Metal) Type 2 (Hosted) Hardware Access Direct Indirect (via Host OS) Performance Native / High Slower (due to OS overhead) Scalability High Low to Medium Management Often remote (web console/CLI) Local GUI Application Typical User IT Administrator Developer / End User","title":"5. Comparison: Type 1 vs. Type 2"},{"location":"ucc141/virtualization_fundamentals/session2/#6-introduction-to-virtualbox","text":"For this course, we will use Oracle VM VirtualBox , a popular open-source Type 2 hypervisor. Cross-Platform: Runs on Windows, Linux, and macOS hosts. Key Components: VirtualBox Manager: The GUI for creating and managing VMs. VBoxManage: A powerful CLI tool for advanced management. Extension Pack: Adds features like USB 2.0/3.0 support, VRDP (Virtual Remote Desktop Protocol), and other advanced capabilities.","title":"6. Introduction to VirtualBox"},{"location":"ucc141/virtualization_fundamentals/session2/#7-lab-exercises-tpcc","text":"Installation: Download and install VirtualBox on your workstation. Optional but Recommended: Install the VirtualBox Extension Pack. Explore Global Preferences: Open VirtualBox and go to File > Preferences . Check the Default Machine Folder . Ensure this drive has plenty of free space. Network Host Manager: Go to File > Tools > Network Manager . Observe any \"Host-Only Ethernet Adapters\" listed. We will use these in future sessions.","title":"7. Lab Exercises (TP/CC)"},{"location":"ucc141/virtualization_fundamentals/session3/","text":"Topic: Creating Your First Virtual Machine 1. The VM Creation Process Creating a Virtual Machine (VM) involves defining a software-based computer specification. When you click \"New\" in VirtualBox, you aren't building a physical machine, but you are creating a configuration file (typically .vbox ) that tells the hypervisor what hardware to emulate. The Wizard Steps: 1. Name & OS Type: Naming the VM and selecting the target OS (e.g., Linux, Windows) helps the hypervisor apply optimal defaults. 2. Memory Size: Allocating RAM. 3. Hard Disk: Creating a virtual hard drive. 2. Allocating Virtual Hardware Virtual CPU (vCPU) By default, a new VM usually gets 1 vCPU. Modern hypervisors allow you to assign multiple cores. Understanding vCPU vs. Core vs. Thread: To allocate resources correctly, you must understand the hierarchy of physical vs. virtual processing: - Physical Core: A physical independent execution unit on your CPU chip. Most mainstream laptops today have 4 to 8 physical cores. - Hardware Thread: Modern CPUs use Simultaneous Multithreading (SMT, or Intel's \"Hyper-Threading\"). This technology allows a single physical core to behave like two logical processors by keeping the core's execution units busy more of the time. - Logical Processor: A CPU with 4 cores and SMT/Hyper-Threading has 8 Logical Processors . This is what the operating system and hypervisor see. - vCPU (Virtual CPU): This is what the hypervisor presents to the VM. In most cases, 1 vCPU maps to 1 Logical Processor (Hardware Thread) on the host. Constraint: You cannot assign more virtual cores than your physical host possesses. Always check your host's core count. Hidden Hardware Features: PAE/NX When you select an OS version in VirtualBox, it often enables these key features automatically: - PAE (Physical Address Extension): Allows 32-bit processors to access more than 4 GB of RAM. - NX (No-Execute) Bit: A security feature that helps prevent malicious code from executing in data-only memory areas (e.g., buffer overflow attacks). It's also called XD (Execute Disable) on Intel CPUs. Virtual RAM This is reserved from your physical host's memory. - Rule of Thumb: Never allocate more than 50-60% of your total host RAM to running VMs. - The Swap Warning: If you over-allocate RAM, your host will start \"swapping\" memory to the hard drive, causing extreme performance degradation (the \"swap death spiral\"). 3. Virtual Hard Disks A virtual disk is simply a large file on your host computer. Common Formats: - VDI (VirtualBox Disk Image): The native format for VirtualBox. - VMDK (Virtual Machine Disk): Format used by VMware. Good for compatibility. Allocation Types: - Dynamically Allocated: The file starts small and grows as you save data inside the VM. Saves space initially. - Fixed Size: The full size is reserved immediately. Better performance, but takes up all the space upfront. 4. Guest Operating Systems & ISO Images A new VM is like a computer with a blank hard drive. We need to install an Operating System (Guest OS). ISO Images: Digital replicas of installation discs. Mounting: You \"insert\" the ISO file into the VM's virtual optical drive via storage settings. 5. Installing the Guest OS Boot Order: The VM detects the bootable ISO in the virtual optical drive. Installer: Follow the OS installer's prompts. Post-Install: You must \"eject\" the ISO (unmount it) from settings so the VM boots from its virtual hard disk on the next restart. 6. Lab Exercises (TP/CC) Download an ISO: Download the Lubuntu or Debian ISO image. Create a New VM: Name: Lab1-Linux Type: Linux, Version: Ubuntu (64-bit) or Debian (64-bit) RAM: 2048 MB (2 GB) HDD: Create a new VDI, Dynamically Allocated, 20 GB. Mount the ISO: Go to Settings > Storage , click the \"Empty\" CD icon, and select your ISO. Install: Start the VM and follow the installer. Verify: Shut down, remove the ISO, and reboot into your new virtual Linux desktop.","title":"Creating Your First VM"},{"location":"ucc141/virtualization_fundamentals/session3/#topic-creating-your-first-virtual-machine","text":"","title":"Topic: Creating Your First Virtual Machine"},{"location":"ucc141/virtualization_fundamentals/session3/#1-the-vm-creation-process","text":"Creating a Virtual Machine (VM) involves defining a software-based computer specification. When you click \"New\" in VirtualBox, you aren't building a physical machine, but you are creating a configuration file (typically .vbox ) that tells the hypervisor what hardware to emulate. The Wizard Steps: 1. Name & OS Type: Naming the VM and selecting the target OS (e.g., Linux, Windows) helps the hypervisor apply optimal defaults. 2. Memory Size: Allocating RAM. 3. Hard Disk: Creating a virtual hard drive.","title":"1. The VM Creation Process"},{"location":"ucc141/virtualization_fundamentals/session3/#2-allocating-virtual-hardware","text":"","title":"2. Allocating Virtual Hardware"},{"location":"ucc141/virtualization_fundamentals/session3/#virtual-cpu-vcpu","text":"By default, a new VM usually gets 1 vCPU. Modern hypervisors allow you to assign multiple cores. Understanding vCPU vs. Core vs. Thread: To allocate resources correctly, you must understand the hierarchy of physical vs. virtual processing: - Physical Core: A physical independent execution unit on your CPU chip. Most mainstream laptops today have 4 to 8 physical cores. - Hardware Thread: Modern CPUs use Simultaneous Multithreading (SMT, or Intel's \"Hyper-Threading\"). This technology allows a single physical core to behave like two logical processors by keeping the core's execution units busy more of the time. - Logical Processor: A CPU with 4 cores and SMT/Hyper-Threading has 8 Logical Processors . This is what the operating system and hypervisor see. - vCPU (Virtual CPU): This is what the hypervisor presents to the VM. In most cases, 1 vCPU maps to 1 Logical Processor (Hardware Thread) on the host. Constraint: You cannot assign more virtual cores than your physical host possesses. Always check your host's core count.","title":"Virtual CPU (vCPU)"},{"location":"ucc141/virtualization_fundamentals/session3/#hidden-hardware-features-paenx","text":"When you select an OS version in VirtualBox, it often enables these key features automatically: - PAE (Physical Address Extension): Allows 32-bit processors to access more than 4 GB of RAM. - NX (No-Execute) Bit: A security feature that helps prevent malicious code from executing in data-only memory areas (e.g., buffer overflow attacks). It's also called XD (Execute Disable) on Intel CPUs.","title":"Hidden Hardware Features: PAE/NX"},{"location":"ucc141/virtualization_fundamentals/session3/#virtual-ram","text":"This is reserved from your physical host's memory. - Rule of Thumb: Never allocate more than 50-60% of your total host RAM to running VMs. - The Swap Warning: If you over-allocate RAM, your host will start \"swapping\" memory to the hard drive, causing extreme performance degradation (the \"swap death spiral\").","title":"Virtual RAM"},{"location":"ucc141/virtualization_fundamentals/session3/#3-virtual-hard-disks","text":"A virtual disk is simply a large file on your host computer. Common Formats: - VDI (VirtualBox Disk Image): The native format for VirtualBox. - VMDK (Virtual Machine Disk): Format used by VMware. Good for compatibility. Allocation Types: - Dynamically Allocated: The file starts small and grows as you save data inside the VM. Saves space initially. - Fixed Size: The full size is reserved immediately. Better performance, but takes up all the space upfront.","title":"3. Virtual Hard Disks"},{"location":"ucc141/virtualization_fundamentals/session3/#4-guest-operating-systems-iso-images","text":"A new VM is like a computer with a blank hard drive. We need to install an Operating System (Guest OS). ISO Images: Digital replicas of installation discs. Mounting: You \"insert\" the ISO file into the VM's virtual optical drive via storage settings.","title":"4. Guest Operating Systems &amp; ISO Images"},{"location":"ucc141/virtualization_fundamentals/session3/#5-installing-the-guest-os","text":"Boot Order: The VM detects the bootable ISO in the virtual optical drive. Installer: Follow the OS installer's prompts. Post-Install: You must \"eject\" the ISO (unmount it) from settings so the VM boots from its virtual hard disk on the next restart.","title":"5. Installing the Guest OS"},{"location":"ucc141/virtualization_fundamentals/session3/#6-lab-exercises-tpcc","text":"Download an ISO: Download the Lubuntu or Debian ISO image. Create a New VM: Name: Lab1-Linux Type: Linux, Version: Ubuntu (64-bit) or Debian (64-bit) RAM: 2048 MB (2 GB) HDD: Create a new VDI, Dynamically Allocated, 20 GB. Mount the ISO: Go to Settings > Storage , click the \"Empty\" CD icon, and select your ISO. Install: Start the VM and follow the installer. Verify: Shut down, remove the ISO, and reboot into your new virtual Linux desktop.","title":"6. Lab Exercises (TP/CC)"},{"location":"ucc141/virtualization_fundamentals/session4/","text":"1. Modifying VM Settings: Why Power State Matters Virtual hardware behaves like real hardware in one important way: some components must exist before the computer turns on . Powered Off Changes (Most Hardware) When the VM is off, the hypervisor can safely rewire the virtual motherboard. You typically must power off the VM to change: RAM size Number of CPU cores Storage controllers Adding or removing virtual hard disks Why? Because the guest OS detects these at boot time, just like a real BIOS/UEFI scan. Running Changes (Hot-plug Features) Some components are designed to be hot-swappable: Network adapter connection (plug/unplug the cable) CD/DVD ISO files USB devices These behave like plugging in a USB stick or Ethernet cable on a real computer. 2. CPU and RAM: The Performance Balancing Act Your host OS and guest OS share the same physical hardware. Virtualization is not magic; it is negotiation. RAM Allocation (System > Motherboard) RAM assigned to the VM is reserved while the VM runs . If you give too much RAM to the VM: The host OS slows down Everything becomes laggy That green zone in VirtualBox is a safety buffer. Staying inside it keeps the host breathing comfortably. \ud83e\udec1 Best practice: Linux VMs: 1\u20132 GB for light tasks, 4 GB+ for desktops Windows VMs: 4 GB minimum for usability CPU Allocation (System > Processor) Each VM \u201ccore\u201d is a virtual CPU thread , not a physical core. Assigning more cores: Helps with compilation, compression, databases Does not help much for single-threaded tasks Execution Cap This is a CPU speed governor: 100% = VM can use full assigned CPU time 50% = VM can only use half of its allowed CPU This is useful on shared machines or labs where one VM must not dominate. PAE/NX PAE allows 32-bit OSs to access more than 4 GB RAM NX helps with memory protection and security Most modern OSs expect this to be enabled. 3. Virtual Storage: The VM\u2019s Memory Palace Virtual disks are just files on the host, but to the guest OS they look like real drives. 3.1 Storage Controllers Explained The controller defines how the disk \u201cconnects\u201d to the VM. IDE Old and slow Used mainly for legacy OSs or CD/DVD drives SATA Default and reliable Good compatibility and performance NVMe Simulates modern SSDs Faster I/O, lower latency Best for modern Linux and Windows guests Choose SATA for compatibility, NVMe for performance. 3.2 Virtual Disk Formats: Why They Matter Each format is like a suitcase built for a different airline. VDI Best choice for VirtualBox Supports snapshots, resizing, encryption VMDK Good for moving VMs between VirtualBox and VMware Common in enterprise environments VHD/VHDX Designed for Microsoft ecosystems Ideal for Hyper-V and Azure QCOW2 Advanced features like compression and snapshots Mostly used with KVM/QEMU Rule of thumb: Stay native unless you plan to migrate. 3.3 Fixed vs Dynamic Disks This is about when disk space is reserved. Dynamically Allocated The file grows as data is written A 50 GB disk with 5 GB used = ~5 GB on host Ideal for labs and testing Downside: The disk file expands in chunks, which can slightly reduce performance over time. Fixed Size Entire disk space reserved immediately Faster and more predictable performance Preferred for databases and servers Trade-off: Uses full space even if mostly empty. 4. Adding a Second Virtual Disk: What Really Happens When you add a new disk in VirtualBox: The hypervisor creates a new disk file It connects it to the virtual controller The guest OS sees it as raw hardware The OS does not automatically use it. Inside the Guest OS (Linux Example) lsblk shows: sda \u2192 original system disk sdb \u2192 new, empty disk You must: Create a partition Format it (ext4, xfs, etc.) Mount it to a directory This separation mirrors real-world system administration skills. 5. Display, Audio, and Network Tweaks Display Video Memory Higher values allow higher resolutions Important for GUI desktops Graphics Controller VMSVGA \u2192 Linux VBoxSVGA \u2192 Windows Wrong choice = black screens or poor performance. Audio Disabling audio: Saves CPU and RAM Useful for server VMs Network Network adapters behave like virtual NICs Mode (NAT, Bridged, Host-Only) defines how the VM talks to the world Covered fully in the next session 6. Lab Exercises: What You Are Learning Each lab task maps directly to real admin skills: Resource Tuning You learn: Capacity planning Performance trade-offs Host vs guest resource management Adding Storage You learn: Disk provisioning Storage expansion without downtime (enterprise reality) OS-level disk management Disk Initialization You practice: Identifying block devices Partitioning and formatting Filesystem mounting This is exactly what sysadmins do on cloud VMs every day. Final Thought Virtual machines are not fake computers. They are software-defined hardware . Once you understand that, configuring VMs stops being clicking menus and starts being engineering.","title":"VM Hardware and Configuration"},{"location":"ucc141/virtualization_fundamentals/session4/#1-modifying-vm-settings-why-power-state-matters","text":"Virtual hardware behaves like real hardware in one important way: some components must exist before the computer turns on .","title":"1. Modifying VM Settings: Why Power State Matters"},{"location":"ucc141/virtualization_fundamentals/session4/#powered-off-changes-most-hardware","text":"When the VM is off, the hypervisor can safely rewire the virtual motherboard. You typically must power off the VM to change: RAM size Number of CPU cores Storage controllers Adding or removing virtual hard disks Why? Because the guest OS detects these at boot time, just like a real BIOS/UEFI scan.","title":"Powered Off Changes (Most Hardware)"},{"location":"ucc141/virtualization_fundamentals/session4/#running-changes-hot-plug-features","text":"Some components are designed to be hot-swappable: Network adapter connection (plug/unplug the cable) CD/DVD ISO files USB devices These behave like plugging in a USB stick or Ethernet cable on a real computer.","title":"Running Changes (Hot-plug Features)"},{"location":"ucc141/virtualization_fundamentals/session4/#2-cpu-and-ram-the-performance-balancing-act","text":"Your host OS and guest OS share the same physical hardware. Virtualization is not magic; it is negotiation.","title":"2. CPU and RAM: The Performance Balancing Act"},{"location":"ucc141/virtualization_fundamentals/session4/#ram-allocation-system-motherboard","text":"RAM assigned to the VM is reserved while the VM runs . If you give too much RAM to the VM: The host OS slows down Everything becomes laggy That green zone in VirtualBox is a safety buffer. Staying inside it keeps the host breathing comfortably. \ud83e\udec1 Best practice: Linux VMs: 1\u20132 GB for light tasks, 4 GB+ for desktops Windows VMs: 4 GB minimum for usability","title":"RAM Allocation (System &gt; Motherboard)"},{"location":"ucc141/virtualization_fundamentals/session4/#cpu-allocation-system-processor","text":"Each VM \u201ccore\u201d is a virtual CPU thread , not a physical core. Assigning more cores: Helps with compilation, compression, databases Does not help much for single-threaded tasks","title":"CPU Allocation (System &gt; Processor)"},{"location":"ucc141/virtualization_fundamentals/session4/#execution-cap","text":"This is a CPU speed governor: 100% = VM can use full assigned CPU time 50% = VM can only use half of its allowed CPU This is useful on shared machines or labs where one VM must not dominate.","title":"Execution Cap"},{"location":"ucc141/virtualization_fundamentals/session4/#paenx","text":"PAE allows 32-bit OSs to access more than 4 GB RAM NX helps with memory protection and security Most modern OSs expect this to be enabled.","title":"PAE/NX"},{"location":"ucc141/virtualization_fundamentals/session4/#3-virtual-storage-the-vms-memory-palace","text":"Virtual disks are just files on the host, but to the guest OS they look like real drives.","title":"3. Virtual Storage: The VM\u2019s Memory Palace"},{"location":"ucc141/virtualization_fundamentals/session4/#31-storage-controllers-explained","text":"The controller defines how the disk \u201cconnects\u201d to the VM. IDE Old and slow Used mainly for legacy OSs or CD/DVD drives SATA Default and reliable Good compatibility and performance NVMe Simulates modern SSDs Faster I/O, lower latency Best for modern Linux and Windows guests Choose SATA for compatibility, NVMe for performance.","title":"3.1 Storage Controllers Explained"},{"location":"ucc141/virtualization_fundamentals/session4/#32-virtual-disk-formats-why-they-matter","text":"Each format is like a suitcase built for a different airline. VDI Best choice for VirtualBox Supports snapshots, resizing, encryption VMDK Good for moving VMs between VirtualBox and VMware Common in enterprise environments VHD/VHDX Designed for Microsoft ecosystems Ideal for Hyper-V and Azure QCOW2 Advanced features like compression and snapshots Mostly used with KVM/QEMU Rule of thumb: Stay native unless you plan to migrate.","title":"3.2 Virtual Disk Formats: Why They Matter"},{"location":"ucc141/virtualization_fundamentals/session4/#33-fixed-vs-dynamic-disks","text":"This is about when disk space is reserved.","title":"3.3 Fixed vs Dynamic Disks"},{"location":"ucc141/virtualization_fundamentals/session4/#dynamically-allocated","text":"The file grows as data is written A 50 GB disk with 5 GB used = ~5 GB on host Ideal for labs and testing Downside: The disk file expands in chunks, which can slightly reduce performance over time.","title":"Dynamically Allocated"},{"location":"ucc141/virtualization_fundamentals/session4/#fixed-size","text":"Entire disk space reserved immediately Faster and more predictable performance Preferred for databases and servers Trade-off: Uses full space even if mostly empty.","title":"Fixed Size"},{"location":"ucc141/virtualization_fundamentals/session4/#4-adding-a-second-virtual-disk-what-really-happens","text":"When you add a new disk in VirtualBox: The hypervisor creates a new disk file It connects it to the virtual controller The guest OS sees it as raw hardware The OS does not automatically use it.","title":"4. Adding a Second Virtual Disk: What Really Happens"},{"location":"ucc141/virtualization_fundamentals/session4/#inside-the-guest-os-linux-example","text":"lsblk shows: sda \u2192 original system disk sdb \u2192 new, empty disk You must: Create a partition Format it (ext4, xfs, etc.) Mount it to a directory This separation mirrors real-world system administration skills.","title":"Inside the Guest OS (Linux Example)"},{"location":"ucc141/virtualization_fundamentals/session4/#5-display-audio-and-network-tweaks","text":"","title":"5. Display, Audio, and Network Tweaks"},{"location":"ucc141/virtualization_fundamentals/session4/#display","text":"Video Memory Higher values allow higher resolutions Important for GUI desktops Graphics Controller VMSVGA \u2192 Linux VBoxSVGA \u2192 Windows Wrong choice = black screens or poor performance.","title":"Display"},{"location":"ucc141/virtualization_fundamentals/session4/#audio","text":"Disabling audio: Saves CPU and RAM Useful for server VMs","title":"Audio"},{"location":"ucc141/virtualization_fundamentals/session4/#network","text":"Network adapters behave like virtual NICs Mode (NAT, Bridged, Host-Only) defines how the VM talks to the world Covered fully in the next session","title":"Network"},{"location":"ucc141/virtualization_fundamentals/session4/#6-lab-exercises-what-you-are-learning","text":"Each lab task maps directly to real admin skills:","title":"6. Lab Exercises: What You Are Learning"},{"location":"ucc141/virtualization_fundamentals/session4/#resource-tuning","text":"You learn: Capacity planning Performance trade-offs Host vs guest resource management","title":"Resource Tuning"},{"location":"ucc141/virtualization_fundamentals/session4/#adding-storage","text":"You learn: Disk provisioning Storage expansion without downtime (enterprise reality) OS-level disk management","title":"Adding Storage"},{"location":"ucc141/virtualization_fundamentals/session4/#disk-initialization","text":"You practice: Identifying block devices Partitioning and formatting Filesystem mounting This is exactly what sysadmins do on cloud VMs every day.","title":"Disk Initialization"},{"location":"ucc141/virtualization_fundamentals/session4/#final-thought","text":"Virtual machines are not fake computers. They are software-defined hardware . Once you understand that, configuring VMs stops being clicking menus and starts being engineering.","title":"Final Thought"},{"location":"ucc141/virtualization_fundamentals/session5/","text":"This course introduces virtual machine (VM) networking concepts commonly used in hypervisors such as VirtualBox and VMware. It combines theory, comparisons, hands-on labs, and validation activities. 1. Theory Lesson: Virtual Network Modes Overview Virtual machines behave like separate computers, but their network connection depends on how the hypervisor links them to the host and the outside world. Think of the hypervisor as a smart switchboard deciding where VM traffic can go. 1.1 NAT (Network Address Translation) How it works The hypervisor acts like a home router. The VM sits on a private network and shares the host\u2019s IP address to reach the internet. Analogy A phone using Wi-Fi at home. The phone has a private address, but the router represents it to the internet. Diagram (conceptual) [ VM ] -- private IP --> [ Hypervisor NAT ] -- public IP --> Internet Key characteristics VM gets a private IP from the hypervisor Outbound internet access works automatically External devices cannot directly reach the VM Practical use case Safely browsing the internet or installing updates inside a VM without exposing it to the local network. 1.2 Bridged Networking How it works The VM connects directly to the physical network, appearing as another device on the LAN. Analogy Plugging an extra laptop into the same switch as your PC. Diagram (conceptual) [ VM ] -- LAN --> [ Switch / Router ] -- LAN --> Other devices Key characteristics VM receives an IP from the same DHCP server as the host Full access to LAN and internet Other devices can see and reach the VM Practical use case Hosting a web or game server that must be reachable by other machines on the network. 1.3 Host-Only Networking How it works The VM and host form a private network that does not connect to the internet. Analogy A private Ethernet cable directly between two computers. Diagram (conceptual) [ Host ] <---- private LAN ----> [ VM ] Key characteristics Private IP addresses assigned by the hypervisor No internet access by default VM can communicate with the host Practical use case Testing software or services that should only be accessed from the host machine. 1.4 Internal Networking How it works VMs communicate only with each other on an isolated virtual network. Analogy A closed lab room where students can talk to each other but not to anyone outside. Diagram (conceptual) [ VM1 ] <---> [ VM2 ] <---> [ VM3 ] (no host, no internet) Key characteristics No host or internet connectivity Manual or internal DHCP IP assignment Completely isolated environment Practical use case Practicing network attacks and defenses in a safe, isolated lab. 2. Use Cases and Comparisons Comparison Table Feature NAT Bridged Host-Only Internal IP Assignment Hypervisor DHCP LAN DHCP Hypervisor DHCP Manual or internal DHCP Internet Access Yes (outbound) Yes No (by default) No Visible to Host Limited Yes Yes No VM-to-VM Communication Limited Yes (via LAN) Yes Yes Security Level High Low Medium Very High Security notes NAT hides VMs from the LAN, reducing attack surface. Bridged mode exposes VMs like real machines and must be secured. Host-Only allows controlled testing without outside interference. Internal is safest for experiments involving risky configurations. 3. Lab: VM Network Configuration Lab Objective Configure two virtual machines with different networking modes and observe behavior. Requirements Two VMs (VM1 and VM2) Linux or Windows operating systems VirtualBox or VMware Step 1: Configure VM1 (Host-Only) Power off VM1 Open VM settings Go to Network Select Host-Only Adapter Save settings and start VM1 Expected IP range Example: 192.168.56.x Screenshot description Network settings panel showing Adapter 1 set to Host-Only Step 2: Configure VM2 (Bridged) Power off VM2 Open VM settings Go to Network Select Bridged Adapter Choose active network interface (Ethernet or Wi-Fi) Start VM2 Expected IP range Same subnet as host (e.g., 192.168.1.x) Screenshot description Network settings panel showing Bridged Adapter with Wi-Fi selected 4. Network Verification & Troubleshooting Verification Commands Check IP address Windows: ipconfig Linux/macOS: ifconfig or ip addr Check connectivity ping <host IP> ping <gateway> Check hostname hostname View routes Windows: route print Linux: ip route Expected Results VM1 (Host-Only) can ping host but not internet VM2 (Bridged) can ping host, LAN devices, and internet Common Troubleshooting Tips Ensure VM network adapter is enabled Verify correct adapter type selected Disable host firewall temporarily for testing Confirm DHCP is active Restart VM network service if IP is missing 5. Knowledge Check & Review Multiple Choice Questions Which mode hides the VM behind the host\u2019s IP? A. Bridged B. NAT C. Host-Only D. Internal Which mode allows other LAN devices to access the VM? A. NAT B. Internal C. Bridged D. Host-Only Which mode is best for isolated multi-VM labs? A. Bridged B. NAT C. Host-Only D. Internal Which network mode allows VM-to-host communication without internet? A. NAT B. Host-Only C. Bridged D. Internal Which mode has the highest exposure risk? A. Internal B. Host-Only C. NAT D. Bridged","title":"Virtual Network Modes in Hypervisors"},{"location":"ucc141/virtualization_fundamentals/session5/#1-theory-lesson-virtual-network-modes-overview","text":"Virtual machines behave like separate computers, but their network connection depends on how the hypervisor links them to the host and the outside world. Think of the hypervisor as a smart switchboard deciding where VM traffic can go.","title":"1. Theory Lesson: Virtual Network Modes Overview"},{"location":"ucc141/virtualization_fundamentals/session5/#11-nat-network-address-translation","text":"How it works The hypervisor acts like a home router. The VM sits on a private network and shares the host\u2019s IP address to reach the internet. Analogy A phone using Wi-Fi at home. The phone has a private address, but the router represents it to the internet. Diagram (conceptual) [ VM ] -- private IP --> [ Hypervisor NAT ] -- public IP --> Internet Key characteristics VM gets a private IP from the hypervisor Outbound internet access works automatically External devices cannot directly reach the VM Practical use case Safely browsing the internet or installing updates inside a VM without exposing it to the local network.","title":"1.1 NAT (Network Address Translation)"},{"location":"ucc141/virtualization_fundamentals/session5/#12-bridged-networking","text":"How it works The VM connects directly to the physical network, appearing as another device on the LAN. Analogy Plugging an extra laptop into the same switch as your PC. Diagram (conceptual) [ VM ] -- LAN --> [ Switch / Router ] -- LAN --> Other devices Key characteristics VM receives an IP from the same DHCP server as the host Full access to LAN and internet Other devices can see and reach the VM Practical use case Hosting a web or game server that must be reachable by other machines on the network.","title":"1.2 Bridged Networking"},{"location":"ucc141/virtualization_fundamentals/session5/#13-host-only-networking","text":"How it works The VM and host form a private network that does not connect to the internet. Analogy A private Ethernet cable directly between two computers. Diagram (conceptual) [ Host ] <---- private LAN ----> [ VM ] Key characteristics Private IP addresses assigned by the hypervisor No internet access by default VM can communicate with the host Practical use case Testing software or services that should only be accessed from the host machine.","title":"1.3 Host-Only Networking"},{"location":"ucc141/virtualization_fundamentals/session5/#14-internal-networking","text":"How it works VMs communicate only with each other on an isolated virtual network. Analogy A closed lab room where students can talk to each other but not to anyone outside. Diagram (conceptual) [ VM1 ] <---> [ VM2 ] <---> [ VM3 ] (no host, no internet) Key characteristics No host or internet connectivity Manual or internal DHCP IP assignment Completely isolated environment Practical use case Practicing network attacks and defenses in a safe, isolated lab.","title":"1.4 Internal Networking"},{"location":"ucc141/virtualization_fundamentals/session5/#2-use-cases-and-comparisons","text":"","title":"2. Use Cases and Comparisons"},{"location":"ucc141/virtualization_fundamentals/session5/#comparison-table","text":"Feature NAT Bridged Host-Only Internal IP Assignment Hypervisor DHCP LAN DHCP Hypervisor DHCP Manual or internal DHCP Internet Access Yes (outbound) Yes No (by default) No Visible to Host Limited Yes Yes No VM-to-VM Communication Limited Yes (via LAN) Yes Yes Security Level High Low Medium Very High Security notes NAT hides VMs from the LAN, reducing attack surface. Bridged mode exposes VMs like real machines and must be secured. Host-Only allows controlled testing without outside interference. Internal is safest for experiments involving risky configurations.","title":"Comparison Table"},{"location":"ucc141/virtualization_fundamentals/session5/#3-lab-vm-network-configuration","text":"","title":"3. Lab: VM Network Configuration"},{"location":"ucc141/virtualization_fundamentals/session5/#lab-objective","text":"Configure two virtual machines with different networking modes and observe behavior.","title":"Lab Objective"},{"location":"ucc141/virtualization_fundamentals/session5/#requirements","text":"Two VMs (VM1 and VM2) Linux or Windows operating systems VirtualBox or VMware","title":"Requirements"},{"location":"ucc141/virtualization_fundamentals/session5/#step-1-configure-vm1-host-only","text":"Power off VM1 Open VM settings Go to Network Select Host-Only Adapter Save settings and start VM1 Expected IP range Example: 192.168.56.x Screenshot description Network settings panel showing Adapter 1 set to Host-Only","title":"Step 1: Configure VM1 (Host-Only)"},{"location":"ucc141/virtualization_fundamentals/session5/#step-2-configure-vm2-bridged","text":"Power off VM2 Open VM settings Go to Network Select Bridged Adapter Choose active network interface (Ethernet or Wi-Fi) Start VM2 Expected IP range Same subnet as host (e.g., 192.168.1.x) Screenshot description Network settings panel showing Bridged Adapter with Wi-Fi selected","title":"Step 2: Configure VM2 (Bridged)"},{"location":"ucc141/virtualization_fundamentals/session5/#4-network-verification-troubleshooting","text":"","title":"4. Network Verification &amp; Troubleshooting"},{"location":"ucc141/virtualization_fundamentals/session5/#verification-commands","text":"Check IP address Windows: ipconfig Linux/macOS: ifconfig or ip addr Check connectivity ping <host IP> ping <gateway> Check hostname hostname View routes Windows: route print Linux: ip route","title":"Verification Commands"},{"location":"ucc141/virtualization_fundamentals/session5/#expected-results","text":"VM1 (Host-Only) can ping host but not internet VM2 (Bridged) can ping host, LAN devices, and internet","title":"Expected Results"},{"location":"ucc141/virtualization_fundamentals/session5/#common-troubleshooting-tips","text":"Ensure VM network adapter is enabled Verify correct adapter type selected Disable host firewall temporarily for testing Confirm DHCP is active Restart VM network service if IP is missing","title":"Common Troubleshooting Tips"},{"location":"ucc141/virtualization_fundamentals/session5/#5-knowledge-check-review","text":"","title":"5. Knowledge Check &amp; Review"},{"location":"ucc141/virtualization_fundamentals/session5/#multiple-choice-questions","text":"Which mode hides the VM behind the host\u2019s IP? A. Bridged B. NAT C. Host-Only D. Internal Which mode allows other LAN devices to access the VM? A. NAT B. Internal C. Bridged D. Host-Only Which mode is best for isolated multi-VM labs? A. Bridged B. NAT C. Host-Only D. Internal Which network mode allows VM-to-host communication without internet? A. NAT B. Host-Only C. Bridged D. Internal Which mode has the highest exposure risk? A. Internal B. Host-Only C. NAT D. Bridged","title":"Multiple Choice Questions"},{"location":"ucc141/virtualization_fundamentals/session6/","text":"By the end of this session, learners will be able to: Define VM snapshots and explain how they work internally Create, revert, and delete snapshots safely Interpret snapshot trees and understand delta disks Use snapshots to recover from configuration failures Apply snapshot best practices and avoid common pitfalls 1. What Is a Snapshot? (With Diagram) A snapshot is a point-in-time record of a virtual machine\u2019s state, mainly its disk contents and sometimes its memory. Snapshot Concept Diagram Before Snapshot ---------------- [ VM Disk.vmdk ] | v Running VM After Snapshot -------------- [ VM Disk.vmdk ] (Read-only) | v [ Delta Disk 0001.vmdk ] | v Running VM Key idea: The original disk is frozen All new changes go into a delta disk Reverting discards delta changes 2. Snapshot Tree Explained (Visual) Snapshots can form a tree if multiple snapshots are taken. Base Disk | +-- Snapshot A | | | +-- Snapshot B | +-- Snapshot C Meaning: Snapshot B depends on Snapshot A Deleting Snapshot A affects Snapshot B Longer chains = slower disk performance 3. Snapshot vs Backup (Comparison Table) Feature Snapshot Backup Independent No Yes Long-term use No Yes Fast rollback Yes No Production-safe Limited Yes Snapshots are temporary safety checkpoints , not archival storage. 4. When to Use Snapshots (Use Cases) Good use cases: Before software installation Before configuration changes OS updates Training labs Testing risky commands Bad use cases: Databases in production Long-term storage Disaster recovery 5. Snapshot Lifecycle Diagram Take Snapshot | v Make Changes | v [ Works ? ] ---- Yes ----> Delete Snapshot | No | v Revert to Snapshot 6. Practical Lab: Snapshot Recovery with a Web Server Lab Objective Use a snapshot to recover a Linux VM after breaking a web server configuration. Lab Environment Linux VM (Ubuntu 20.04+ recommended) User with sudo privileges Internet access Part 1: Install a Web Server (Apache) Step 1: Update Packages sudo apt update Step 2: Install Apache sudo apt install apache2 -y Step 3: Start and Enable Apache sudo systemctl start apache2 sudo systemctl enable apache2 Step 4: Verify Service Status sudo systemctl status apache2 Step 5: Test Web Server From the VM: curl http://localhost Or from a browser: http://<VM-IP-address> Expected result: Apache default page loads successfully. Part 2: Take a Snapshot Snapshot Action (Hypervisor GUI) Snapshot name: Working Web Server Description: Apache installed and running correctly Snapshot Timing Diagram: [ Clean OS ] ---> Install Apache ---> [ SNAPSHOT ] ---> Testing Zone Part 3: Break the Web Server Configuration Step 1: Edit Apache Configuration sudo nano /etc/apache2/ports.conf Step 2: Introduce an Error Change: Listen 80 To: Listen eighty Save and exit. Step 3: Restart Apache sudo systemctl restart apache2 Step 4: Check Status sudo systemctl status apache2 Expected result: Service fails Error messages appear Website no longer loads This is an intentional failure. Part 4: Revert to Snapshot Snapshot Revert Process Power off VM (if required) Revert to Working Web Server Power on VM Step 5: Verify Recovery sudo systemctl status apache2 curl http://localhost Expected result: Apache runs normally Configuration error is gone Default page loads again Time-travel successful. 7. What Changed After Revert? (Concept Diagram) Broken VM State ---------------- Apache \u274c Config \u274c Revert Snapshot | v Snapshot State --------------- Apache \u2705 Config \u2705 All changes made after the snapshot vanished. 8. Snapshot Pitfalls (Visual Warning) Too Many Snapshots ------------------ Base Disk | +-- S1 | +-- S2 | +-- S3 | +-- S4 \u26a0\ufe0f Performance drops Best Practices Checklist \u2714 Take snapshots before risky changes \u2714 Use clear names and descriptions \u2714 Delete snapshots when done \u2718 Do not keep snapshots long-term \u2718 Do not use snapshots as backups Session Wrap-Up Snapshots give virtual machines a rewind button, but they are not a reset button for everything. They preserve state, not independence. In this session, learners used snapshots to recover from failure, explored snapshot trees, and saw why cleanup matters. Today\u2019s key idea: Snapshots protect moments. Clones and templates create futures. This sets the stage perfectly for the next class. Reflection & Further Research \ud83e\udded Reflection Questions If snapshots depend on the original VM disk, what happens if that disk is deleted? Why do hypervisors warn administrators about long-lived snapshots? In what scenarios would reverting to a snapshot be dangerous rather than helpful? How does snapshot usage differ between test environments and production systems? Further Research Topics Learners may explore one or more of the following: Difference between full clone and linked clone How snapshot delta disks affect I/O performance Snapshot handling in different hypervisors (VirtualBox, VMware, Hyper-V) Why enterprise environments limit snapshot retention Relationship between snapshots, clones, and templates Concept Bridge to Next Session From Snapshots to Cloning Snapshot --------- One VM One Timeline Rollback-focused Clone / Template ---------------- Multiple VMs Independent Lifecycles Scale-focused Snapshots look backward. Clones and templates look forward.","title":"Snapshots for State Management"},{"location":"ucc141/virtualization_fundamentals/session6/#1-what-is-a-snapshot-with-diagram","text":"A snapshot is a point-in-time record of a virtual machine\u2019s state, mainly its disk contents and sometimes its memory.","title":"1. What Is a Snapshot? (With Diagram)"},{"location":"ucc141/virtualization_fundamentals/session6/#snapshot-concept-diagram","text":"Before Snapshot ---------------- [ VM Disk.vmdk ] | v Running VM After Snapshot -------------- [ VM Disk.vmdk ] (Read-only) | v [ Delta Disk 0001.vmdk ] | v Running VM Key idea: The original disk is frozen All new changes go into a delta disk Reverting discards delta changes","title":"Snapshot Concept Diagram"},{"location":"ucc141/virtualization_fundamentals/session6/#2-snapshot-tree-explained-visual","text":"Snapshots can form a tree if multiple snapshots are taken. Base Disk | +-- Snapshot A | | | +-- Snapshot B | +-- Snapshot C Meaning: Snapshot B depends on Snapshot A Deleting Snapshot A affects Snapshot B Longer chains = slower disk performance","title":"2. Snapshot Tree Explained (Visual)"},{"location":"ucc141/virtualization_fundamentals/session6/#3-snapshot-vs-backup-comparison-table","text":"Feature Snapshot Backup Independent No Yes Long-term use No Yes Fast rollback Yes No Production-safe Limited Yes Snapshots are temporary safety checkpoints , not archival storage.","title":"3. Snapshot vs Backup (Comparison Table)"},{"location":"ucc141/virtualization_fundamentals/session6/#4-when-to-use-snapshots-use-cases","text":"Good use cases: Before software installation Before configuration changes OS updates Training labs Testing risky commands Bad use cases: Databases in production Long-term storage Disaster recovery","title":"4. When to Use Snapshots (Use Cases)"},{"location":"ucc141/virtualization_fundamentals/session6/#5-snapshot-lifecycle-diagram","text":"Take Snapshot | v Make Changes | v [ Works ? ] ---- Yes ----> Delete Snapshot | No | v Revert to Snapshot","title":"5. Snapshot Lifecycle Diagram"},{"location":"ucc141/virtualization_fundamentals/session6/#6-practical-lab-snapshot-recovery-with-a-web-server","text":"","title":"6. Practical Lab: Snapshot Recovery with a Web Server"},{"location":"ucc141/virtualization_fundamentals/session6/#lab-objective","text":"Use a snapshot to recover a Linux VM after breaking a web server configuration.","title":"Lab Objective"},{"location":"ucc141/virtualization_fundamentals/session6/#lab-environment","text":"Linux VM (Ubuntu 20.04+ recommended) User with sudo privileges Internet access","title":"Lab Environment"},{"location":"ucc141/virtualization_fundamentals/session6/#part-1-install-a-web-server-apache","text":"","title":"Part 1: Install a Web Server (Apache)"},{"location":"ucc141/virtualization_fundamentals/session6/#step-1-update-packages","text":"sudo apt update","title":"Step 1: Update Packages"},{"location":"ucc141/virtualization_fundamentals/session6/#step-2-install-apache","text":"sudo apt install apache2 -y","title":"Step 2: Install Apache"},{"location":"ucc141/virtualization_fundamentals/session6/#step-3-start-and-enable-apache","text":"sudo systemctl start apache2 sudo systemctl enable apache2","title":"Step 3: Start and Enable Apache"},{"location":"ucc141/virtualization_fundamentals/session6/#step-4-verify-service-status","text":"sudo systemctl status apache2","title":"Step 4: Verify Service Status"},{"location":"ucc141/virtualization_fundamentals/session6/#step-5-test-web-server","text":"From the VM: curl http://localhost Or from a browser: http://<VM-IP-address> Expected result: Apache default page loads successfully.","title":"Step 5: Test Web Server"},{"location":"ucc141/virtualization_fundamentals/session6/#part-2-take-a-snapshot","text":"","title":"Part 2: Take a Snapshot"},{"location":"ucc141/virtualization_fundamentals/session6/#snapshot-action-hypervisor-gui","text":"Snapshot name: Working Web Server Description: Apache installed and running correctly Snapshot Timing Diagram: [ Clean OS ] ---> Install Apache ---> [ SNAPSHOT ] ---> Testing Zone","title":"Snapshot Action (Hypervisor GUI)"},{"location":"ucc141/virtualization_fundamentals/session6/#part-3-break-the-web-server-configuration","text":"","title":"Part 3: Break the Web Server Configuration"},{"location":"ucc141/virtualization_fundamentals/session6/#step-1-edit-apache-configuration","text":"sudo nano /etc/apache2/ports.conf","title":"Step 1: Edit Apache Configuration"},{"location":"ucc141/virtualization_fundamentals/session6/#step-2-introduce-an-error","text":"Change: Listen 80 To: Listen eighty Save and exit.","title":"Step 2: Introduce an Error"},{"location":"ucc141/virtualization_fundamentals/session6/#step-3-restart-apache","text":"sudo systemctl restart apache2","title":"Step 3: Restart Apache"},{"location":"ucc141/virtualization_fundamentals/session6/#step-4-check-status","text":"sudo systemctl status apache2 Expected result: Service fails Error messages appear Website no longer loads This is an intentional failure.","title":"Step 4: Check Status"},{"location":"ucc141/virtualization_fundamentals/session6/#part-4-revert-to-snapshot","text":"","title":"Part 4: Revert to Snapshot"},{"location":"ucc141/virtualization_fundamentals/session6/#snapshot-revert-process","text":"Power off VM (if required) Revert to Working Web Server Power on VM","title":"Snapshot Revert Process"},{"location":"ucc141/virtualization_fundamentals/session6/#step-5-verify-recovery","text":"sudo systemctl status apache2 curl http://localhost Expected result: Apache runs normally Configuration error is gone Default page loads again Time-travel successful.","title":"Step 5: Verify Recovery"},{"location":"ucc141/virtualization_fundamentals/session6/#7-what-changed-after-revert-concept-diagram","text":"Broken VM State ---------------- Apache \u274c Config \u274c Revert Snapshot | v Snapshot State --------------- Apache \u2705 Config \u2705 All changes made after the snapshot vanished.","title":"7. What Changed After Revert? (Concept Diagram)"},{"location":"ucc141/virtualization_fundamentals/session6/#8-snapshot-pitfalls-visual-warning","text":"Too Many Snapshots ------------------ Base Disk | +-- S1 | +-- S2 | +-- S3 | +-- S4 \u26a0\ufe0f Performance drops","title":"8. Snapshot Pitfalls (Visual Warning)"},{"location":"ucc141/virtualization_fundamentals/session6/#best-practices-checklist","text":"\u2714 Take snapshots before risky changes \u2714 Use clear names and descriptions \u2714 Delete snapshots when done \u2718 Do not keep snapshots long-term \u2718 Do not use snapshots as backups","title":"Best Practices Checklist"},{"location":"ucc141/virtualization_fundamentals/session6/#session-wrap-up","text":"Snapshots give virtual machines a rewind button, but they are not a reset button for everything. They preserve state, not independence. In this session, learners used snapshots to recover from failure, explored snapshot trees, and saw why cleanup matters. Today\u2019s key idea: Snapshots protect moments. Clones and templates create futures. This sets the stage perfectly for the next class.","title":"Session Wrap-Up"},{"location":"ucc141/virtualization_fundamentals/session6/#reflection-further-research","text":"","title":"Reflection &amp; Further Research \ud83e\udded"},{"location":"ucc141/virtualization_fundamentals/session6/#reflection-questions","text":"If snapshots depend on the original VM disk, what happens if that disk is deleted? Why do hypervisors warn administrators about long-lived snapshots? In what scenarios would reverting to a snapshot be dangerous rather than helpful? How does snapshot usage differ between test environments and production systems?","title":"Reflection Questions"},{"location":"ucc141/virtualization_fundamentals/session6/#further-research-topics","text":"Learners may explore one or more of the following: Difference between full clone and linked clone How snapshot delta disks affect I/O performance Snapshot handling in different hypervisors (VirtualBox, VMware, Hyper-V) Why enterprise environments limit snapshot retention Relationship between snapshots, clones, and templates","title":"Further Research Topics"},{"location":"ucc141/virtualization_fundamentals/session6/#concept-bridge-to-next-session","text":"","title":"Concept Bridge to Next Session"},{"location":"ucc141/virtualization_fundamentals/session6/#from-snapshots-to-cloning","text":"Snapshot --------- One VM One Timeline Rollback-focused Clone / Template ---------------- Multiple VMs Independent Lifecycles Scale-focused Snapshots look backward. Clones and templates look forward.","title":"From Snapshots to Cloning"}]}